* [数据结构与算法](#数据结构与算法)
  * [排序](#排序)
     * [各排序时间复杂度](#各排序时间复杂度)
     * [非线性时间比较类排序](#非线性时间比较类排序)
      * [交换排序](#交换排序)
        * [冒泡排序](#冒泡排序)
        * [快速排序](#快速排序)
      * [插入排序](#插入排序)
        * [简单插入排序](#简单插入排序)
        * [希尔排序](#希尔排序)
      * [选择排序](#选择排序)
        * [简单选择排序](#简单选择排序)
        * [堆排序](#堆排序)
      * [归并排序](#归并排序)
        * [二路归并排序](#二路归并排序)
        * [多路归并排序](#多路归并排序)
    * [线性时间比较类排序](#非线性时间比较类排序)
       * [计数排序](#计数排序)
        * [基数排序](#基数排序)
         * [桶排序](#桶排序)
* [十大经典排序算法动画版](https://www.cnblogs.com/onepixel/articles/7674659.html)
* [排序算法的稳定性及其意义](#排序算法的稳定性及其意义)
  
* [树和二叉树](#树和二叉树)
  * [树的定义和基本术语](#树的定义和基本术语)
  * [树的定义](#树的定义)
  * [树的基本术语](#树的基本术语)
* [二叉树](#二叉树)
  * [二叉树的定义](#二叉树的定义)
  * [二叉树的性质](#二叉树的性质)
  * [二叉树的存储结构](#二叉树的存储结构)
* [编译二叉树和线索二叉树](#遍历二叉树和线索二叉树)
  * [遍历二叉树](#遍历二叉树)
  * [线索二叉树](#线索二叉树)
* [树和森林](#树和森林)
  * [树的存储结构](#树的存储结构)
  * [森林与二叉树的转换](#森林与二叉树的转换)
  * [树和森林的遍历](#树和森林的遍历)
* [赫夫曼树及其应用](#赫夫曼树及其应用)
  * [赫夫曼树d的基本概念](#赫夫曼树的基本概念)
  * [赫夫曼树的构造算法](#赫夫曼树的构造算法)
  * [赫夫曼编码](#赫夫曼编码)
  
* [图的定义和基本术语](#图的定义和基本术语)
  * [图的定义](#图的定义)
  * [图的基本术语](#图的基本术语)
* [图的存储结构](#图的存储结构)
  * [邻接矩阵](#邻接矩阵)
  * [邻接表](#邻接表)
* [图的遍历](#图的遍历)
  * [深度优先遍历](#深度优先遍历)
  * [广度优先遍历](#广度优先遍历)
* [图的应用](#图的应用)
  * [最小生成树](#最小生成树)
  * [最短路径](#最短路径)
  * [拓扑排序](#拓扑排序)
  * [关键路径](#关键路径)
  
* [查找的基本概念](#查找的基本概念)
* [线性表的查找](#线性表的查找)
  * [顺序查找](#顺序查找)
  * [折半查找](#折半查找)
* [树表的查找](#树表的查找)
  * [二叉查找](#二叉查找)
  * [平衡二叉树](#平衡二叉树)
  * [B-树](#B-树)
  * [B+树](#B+树)
* [散列表的查找](#散列表的查找)
  * [散列表的基本概念](#散列表的基本概念)
  * [散列函数的构造方法](#散列函数的构造方法)
  * [处理冲突的方法](#处理冲突的方法)
  * [散列表的查找](#散列表的查找)
  
  
  # 数据结构与算法
  ## 排序
  ### 各排序时间复杂度
  排序方法|时间复杂度（平均）|时间复杂度（最坏）|时间复杂度（最好）|空间复杂度|稳定性
  ---|:--:|:--:|:--:|:--:|---:
  插入排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定
  希尔排序|O(n<sup>1.3</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|不稳定
  选择排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|不稳定
  堆排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(1)|不稳定
  冒泡排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定
  快速排序|O(nlog<sub>2</sub>n)|O(n<sup>2</sup>)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|不稳定
  归并排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(n)|稳定
  计数排序|O(n+k)|O(n+k)|O(n+k)|O(n+k)|稳定
  桶排序|O(n+k)|O(n<sup>2</sup>)|O(n)|O(n+k)|稳定
  基数排序|O(n*k)|O(n*k)|O(n*k)|O(n+k)|稳定


# #非线性时间比较类排序
## 交换排序
### 冒泡排序
算法描述：<br>
1.比较相邻的元素。如果第一个比第二个大，就交换它们两个。  
2.对每一对相邻元素作相同的工作，从开始第一对到结尾最后一对，这样在最后的元素应该会是最大的数。  
3.针对所有的元素重复以上的步骤，除最后一个。  
4.重复步骤1~3，直到排序完成。  
代码实现:<br>
```
void BubbleSort(DataType a[],int n)
{
	int i,j,flag=1;
	DataType temp;
	for(i=1;i<n&&flag==1;i++)
	{
		flag=0;
		for(j=0;j<n-i;j++)//注意这里的取值范围                    
		{
			if(a[j].key>a[j+1].key)  
			{
				flag=1;
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
			}
		}
	}
}
```
### 快速排序
快速排序的算法思想：  
通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。  
算法描述：  
快速排序使用分治法来把一串分为两个子串。  
1.从数列中挑出一个元素，称为“基准”。  
2.重新排序数列，所有元素比基准小的摆放在基准前面，所有元素比基准大的摆放在基准后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作。  
3.递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。  
代码实现：
```

```
## 插入排序
### 简单插入排序
原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
算法描述：  
1.从第一个元素开始，该元素可以认为已经被排序  
2.取下一个元素，在已经排好序的元素序列中从后向前扫描  
3.如果该元素（已排好序）大于新元素，将该元素后移一位  
4.重复3，直到找到已排序的元素小于或者等于新元素的位置  
5.将新元素插入到该位置后  
6.重复步骤2~5
代码：  
```

```
### 希尔排序
1959年Shell发明，第一个突破O(n<sup>2</sup>)的排序算法，是简单插入排序的改进版，它与插入排序的不同之处在于，它会优先比较距离教远的元素。希尔排序又叫缩小增量排序。  
算法描述：    
先将整个待排序的记录序列分割称为若干个子序列分别进行直接插入排序，具体算法描述:    
1.选择一个增量序列t1，t2，t3，......tk，其中ti>tj（i<j）,tk=1;  
2.按增量序列个数，对序列进行k趟排序。  
3.每趟排序，根据对应的增量ti，将待排序序列分割成若干长度为m的子序列，分别对应各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。  



# 排序算法的稳定性及其意义
稳定性的定义：<br>
    假定在待排序的记录中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r1=r2，且r1在r2前面，排序后的序列中，r1仍然在r2前面，则称这种排序算法是稳定的；否则称为不稳定的。
    
判断方法：<br>
    对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性，而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种特定的条件下也可以变为不稳定的算法。
    
例如：对于如下的冒泡排序算法，如果将记录交换的条件改为a[j].key>=a[j+1].key，则两个相等的记录就会交换位置。
```
void BubbleSort(DataType a[],int n)
{
	int i,j,flag=1;
	DataType temp;
	for(i=1;i<n&&flag==1;i++)
	{
		flag=0;
		for(j=0;j<n-i;j++)                    
		{
			if(a[j].key>a[j+1].key)  //如果改为a[j].key>=a[j+1].key,就不稳定了
			{
				flag=1;
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
			}
		}
	}
}
```
常见算法的稳定性：  
堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

稳定的意义：  
1.如果只是简单的进行数字的排序，那么稳定性将毫无意义。  

2.如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧毫无意义  

3.如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧毫无意义。  

4.除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序（当然如果需要不需要保持初始的排序意义，那么使用稳定性算法依旧毫无意义）。  

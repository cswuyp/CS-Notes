* [进程调度](#进程调度)
* [孤儿进程和僵死进程](#孤儿进程和僵死进程)
* [简单多线程实例](#简单多线程实例)
* [子进程继承自父进程什么](#子进程继承自父进程什么)
* [如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢](#如果一个多线程程序的某个线程调用了fork函数那么新创建的子进程是否将自动创建和父进程相同数量的线程呢)
* [进程池和线程池](#进程池和线程池)
* [进程编程实例](#进程编程实例)
* [进程和线程之间的区别](#进程和线程之间的区别)
* [为什么进程上下文切换比线程上下文切换代价高](#为什么进程上下文切换比线程上下文切换代价高)
* [线程安全](#线程安全)
* [线程共享资源和独占资源问题](#线程共享资源和独占资源问题)
* [用户级线程和内核级线程](#用户级线程和内核级线程)


# 进程调度
（1）先来先服务调度算法
（2）最短工作优先（SJF）  
（3）最短剩余时间优先（SRTF）  
（4）最高响应比优先（HRRF）  
（5）优先级调度（Priority）  
（6）轮转调度（RR）  
其中，SJF、SRTF为非抢占调度，其余为抢占式调度  

响应比：(等待时间+要求服务时间)/要求服务时间



# 孤儿进程和僵死进程
1.孤儿进程是怎么产生的？  
一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

2.僵死进程是怎么产生的？
一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。

3.危害？  
僵尸进程会占用系统资源，如果很多，则会严重影响服务器的性能  
孤儿进程不会占用系统资源，最终是由init进程托管，有inti进程来释放

4.如何避免僵死进程的产生？

让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid()通知内核释放僵尸进程  

利用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数

让僵尸进程变成孤儿进程，由init回收，就是让父亲死亡


# 简单多线程实例
```c++
#include <iostream>
#include<thread>
using namespace std;
void foo()
{
	for (int i = 0; i < 100; i++)
	{
		cout << "foo() i:" << i << endl;
	}
}
void bar(int x)
{
	for (int j = x; j < 200; j++)
	{
		cout << "bar():j" << j << endl;
	}
}
int main()
{
	thread first(foo);
	thread second(bar,100);
	first.join();
	second.join();
	return 0;
}
```
# 子进程继承自父进程什么
子进程继承父进程
--------------
1.用户号UIDs和用户组号GIDs   
2.环境Environment   
3.堆栈   
4.共享内存   
5.打开文件的描述符   
6.执行时关闭（Close-on-exec）标志   
7.信号（Signal）控制设定   
8.进程组号   
9.当前工作目录   
10.根目录   
11.文件方式创建屏蔽字   
12资源限制   
13.控制终端  

子进程独有
--------
1.进程号PID   
2.不同的父进程号   
3.自己的文件描述符和目录流的拷贝   
4.子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）   
5.不继承异步输入和输出  
6.父进程和子进程拥有独立的地址空间和PID参数。  

# 如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢
　　答案是：否。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。这就引起一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁。不过，pthread提供了一个专门的函数pthread_atfork，以确保fork调用后父进程和子进程都拥有一个清楚的锁状态。
  
　　该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。prepare句柄将在fork调用创建出子进程之前执行。它可以用来锁住所有父进程中的互斥锁。parent句柄则是fork调用创建出子进程之后，而fork返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。child句柄是fork返回之前，在子进程中被执行。和parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的互斥锁。该函数成功时返回0，失败则返回错误码。
  
# 进程池和线程池
动态创建子进程（或子线程）来实现并发服务器的缺点如下：  
1.动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户反应。  
2.动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量的CPU时间。  
3.动态创建的子进程是当前进程的的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。  

进程池的实现原理：  
　　进程池是由服务器预先创建的一组子进程，（线程池中的线程数量应该和CPU数量差不多）。进程池中的所有子进程都运行这相同的代码，并且有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即他们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。  
　　当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态的创建子进程，选择一个已存在的子进程的代价显然要小得多。至于主进程选择哪一个子进程来为新任务服务，则有两种方式：  
1.主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力。  
2.主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠的工作队列上。  
　　当选择好子进程后，主进程还需要使用某种通知进制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使用）。在父线程和子线程之间传递数据要简单得多，因为我们可以把这些数据定义为全局的，那么他们本身就是被所有线程共享的。  
　　用途：  
1.需要大量的线程来完成任务，且完成任务时间比较短，比如WEB服务器完成网页请求这样的任务，使用线程池技术是非常适合的。因为单个任务小，而任务数量巨大，但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Tenlnet会话时间比线程的创建时间大多了。  
2.对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。  
3.接收突发性的大量请求，但不至于使服务器因此产生线程的应用。  

[基于C++11实现线程池的工作原理](https://www.cnblogs.com/ailumiyana/p/10016965.html)

# 进程编程实例
进程编程实例1：  
```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include<stdio.h>
int main()
{
        pid_t child_pid;

        /* 创建一个子进程 */
        child_pid = fork();
        if(child_pid == 0)
        {
                printf("child pid\n");
                exit(0);
        }
        else
        {
                printf("father pid\n");
                sleep(60);
        }

        return 0;
}
```

# 进程和线程之间的区别
（1）进程是资源分配的最小单位，线程是CPU调度的最小单位  
（2）进程有自己的独立地址空间，线程没有  
（3）进程和线程通信方式不同（线程之间的通信比较方便。同一进程下的线程共享数据（比如 全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步和互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信方式进行）  
（4）进程上下文切换开销大，线程开销小  
（5）一个进程挂掉了不会影响其他进程，而线程挂掉了会影响其他线程  
（6）对进程操作一般开销比较大，对线程开销比较小

# 为什么进程上下文切换比线程上下文切换代价高
进程切换分两步：  
1.切换页目录以使用新的地址空间  
2.切换内核栈和硬件上下文  
对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要的，第2步进程和线程切换都要做的。  
切换的性能消耗：  
1.线程上下文切换和进程上下文切换一个主要的区别是线程的切换内存依然是相同的，但是进程切换是不用的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。   

2.另一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲或者相当于的东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。


# 线程安全
如果你的代码所在的线程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也是和预期的是一样的，就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步问题。

线程安全问题都是由全局变量及静态变量引起的。  
若每个线程中对全局变量，静态变量只有读操作，而无写操作，一般来说，这个线程是安全的，若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

# 线程共享资源和独占资源问题
一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的/私有的栈  
线程共享资源：地址空间，全局变量，打开的文件，子进程，闹钟，信号及信号服务程序，记账信息  
线程独占资源：程序计数器，寄存器，栈，状态字  


# 用户级线程和内核级线程
用户级线程：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序的一个进程号，以及其对应的内存空间资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。  

内核级线程：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。

在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。







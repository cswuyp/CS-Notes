* [面向对象的三个基本特征](#面向对象的三个基本特征)
* [虚函数的实现原理](#虚函数的实现原理)
* [怎么用C语言实现虚函数的功能](#怎么用c语言实现虚函数的功能)
* [在C++中的虚函数表是什么时期建立的](#在c中的虚函数表是什么时期建立的)
* [在C++对象内存布局](#在c对象内存布局)
* [在C++自定义的函数一定要先声明或者定义在main函数前面吗？](#在c自定义的函数一定要先声明或者定义在main函数前面吗)
* [sort函数的实现原理](#sort函数的实现原理)
* [malloc函数的实现原理](#malloc函数的实现原理)
* [new实现原理](#new实现原理)
* [new和malloc的区别](#new和malloc的区别)
* [free实现原理](#free实现原理)
* [delete实现原理](#delete实现原理)
* [realloc扩容的原理](#realloc扩容的原理)
* [拷贝构造函数](#拷贝构造函数)
* [构造函数可否为虚函数](#构造函数可否为虚函数)
* [父类的析构函数为什么要声明为虚函数](#父类的析构函数为什么要声明为虚函数)
* [描述内存分配方式以及它们的区别](#描述内存分配方式以及它们的区别)
* [#const与#define相比，有何优点](#const与define相比有何优点)
* [数组与指针的区别](#数组与指针的区别)
* [引用与指针有什么区别](#引用与指针有什么区别)
* [野指针](#野指针)
* [初始化列表初始化](#初始化列表初始化)
* [构造函数初始化](#构造函数初始化)
* [const的作用](#const的作用)
* [const成员函数的使用](#const成员函数的使用)
* [动态创建数组](#动态创建数组)
* [内联函数有什么优点,内联函数与宏定义的区别](#内联函数有什么优点内联函数与宏定义的区别)
* [static关键字作用](#static关键字作用)
* [static成员函数的使用](#static成员函数的使用)
* [右值引用](#右值引用)
* [移动构造函数](#移动构造函数)





* [STL容器的使用](#STL容器的使用)
  * [vector](#vector)
    * [vector基础](#vector基础)
  * [map](#map)
    * [map基础](#map基础)
  * [set](#set)
    * [set基础](#set基础)

* [智能指针](#智能指针)
  * [auto_ptr](#auto_ptr)
  * [unique_ptr](#unique_ptr)
  * [weak_ptr](#weak_ptr)
  * [share_ptr](#share_ptr)

* [C++四种类型转换](#c四种类型转换)
  * [static_cast](#static_cast)
  * [dynamic_cast](#dynamic_cast)
  * [const_cast](#const_cast)
  * [reinterpret_cast](#reinterpret_cast)

# 面向对象的三个基本特征
1.封装  
简单来讲：将现实世界的事物抽象成计算机领域中的对象，对象同时具有属性和行为，这种抽象就是封装。  
封装的一个重要特性：数据隐藏，对象只对外提供与其它对象交互的必要接口，而将自身的某些属性和实现细节对外隐藏，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或者错误的使用了对象的私有部分，这样就在确保正常交互的前提下，保证了安全性。  
2.继承  
面向对象的一个重要特性是复用性，继承是实现复用性的一个重要手段，可以在不重复编写以实现的功能的前提下，对功能进行复用和拓展。  
继承概念的实现方式有两类：实现继承与接口继承  
实现继承是指直接使用基类的属性和方法而无需额外编码的能力。  
接口继承是指仅使用属性和方法的名称，但是子类必须提供实现的能力。  
3.多态  
当存在继承关系时，允许将父类对象看成和它的一个或多个子类对象等同，这样可以根据当前赋给父类对象的子类对象的具体特性以不同的方式进行运行，  
多态的几个前提  
a.要有继承关系  
b.要有方法重写  
c.要有父类引用指向子类对象  
多态的好处  
a.提高了代码的维护性（继承保证）  
b.提高了代码的扩展性（由多态保证）  
多态的限制  
不能使用子类的特有属性和行为 

多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。
动态多态实现有几个条件：  
(1) 虚函数；  
(2) 一个基类的指针或引用指向派生类的对象；  
基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。  
每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。  
虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。      
编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。  

# 虚函数的实现原理

我们可以从虚函数表和虚函数指针来了解虚函数的实现原理。  
简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。
含有虚函数的类会
http://www.cnblogs.com/malecrab/p/5572730.html

# 怎么用C语言实现虚函数的功能
参照前面C++虚函数的实现原理，可以自己添加虚函数指针和虚函数表来实现虚函数功能。  

# 在C++中的虚函数表是什么时期建立的
虚函数表是编译期确定的，虚函数表中存放的是虚函数的地址，而虚函数的地址是在编译期间就确定的所以虚函数表应该也是在编译期就确定的。 
我们在《深度探索C++对象模型》的4.2节能够找到完美的答案，具体摘抄如下：  
“表格中的virtual functions地址是如何构建起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或者替换之。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完美掌控，不需要执行期的任何介入。”

# 在C++对象内存布局
https://www.cnblogs.com/wuyepeng/p/9863296.html

# 在C++自定义的函数一定要先声明或者定义在main函数前面吗？
不一定，C++中的执行总是从main函数开始的（无论main放在什么位置），如果自定义的函数放于main函数之后则需要在main函数前声明该自定义函数，如果自定义的函数放于main函数前则不需要额外的声明，否则在main函数中调用该自定义函数时会出现无法识别。


# sort函数的实现原理
　　STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。
  
# malloc函数的实现原理
https://blog.csdn.net/hudazhe/article/details/79535220

# new实现原理
　　当我们使用关键字new在堆上动态创建一个对象时，它实际上做了三件事：（1）获得一块内存空间，（2）调用构造函数，（3）返回正确的指针。
  https://blog.csdn.net/xxpresent/article/details/53024555
  
# new和malloc的区别
1.new分配内存按照数据类型进行分配，malloc分配内存按照内存大小进行分配。  
2.new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。但是还需要注意的是，之前看过一个题说int p=new int与int p=new int()的区别，因为int属于C++内置对象，不会默认初始化，必须显示调用构造函数，但是对于自定义对象都会默认调用构造函数初始化。翻阅资源后，在C++11中两者没有区别了，自己测试的结构也都是为0；  
3.new返回的是指定对象的指针，而malloc返回的是void* 因此，malloc的返回值一般都需要进行类型转化。  
4.new是一个操作符可以重载，malloc是一个库函数。  
5.new分配的内存要用delete销毁，malloc要用free来销毁，delete销毁的时候会调用对象的析构函数，而free则不会。  
6.malloc分配的内存不够的时候，可以用realloc扩容，new没有这样的操作。  
7.new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try...catch语法，而malloc则应该判断指针的返回值。为了兼容很多C程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL  
8.new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int)* n  
9如果不够可以继续谈new和malloc的实现，空闲链表，分配方法（首次适配原则，最佳适配原则，最差适配原则，快速适配原则）delete和free的实现原理。

# free实现原理

# delete实现原理


# realloc扩容的原理


# 拷贝构造函数

# 构造函数可否为虚函数


# 父类的析构函数为什么要声明为虚函数
1：每个析构函数只会清理自己的成员（成员函数前没有virtual）。

2.为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，当对象销毁时会自动调用基类的析构函数，如果此时基类的析构函数为虚函数才会再调用基类指针指向的派生类的析构函数，否则不会调用派生类的析构函数造成内存泄露。

# 描述内存分配方式以及它们的区别

# #const与#define相比，有何优点

# 数组与指针的区别

# 引用与指针有什么区别
1.指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问。  
2.指针可以改变地址，从而改变所指的对象，而引用一经初始化就不可更改  
3.引用在定义时必须初始化，而指针则不需要。  
4.指针有指向常量的指针和指针常量，而引用没有常量引用    
5.指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全很多但是比较死板。  


# 野指针

# 初始化列表初始化

# 构造函数初始化


# const的作用
1.const修饰全局变量  
2.const修饰局部变量  
3.const修饰指针，const int*  
4.const修饰指针指向的对象，int * const;    
5.const修饰引用该做形参  
6.const修饰成员变量，必须在构造函数列表中初始化  
7.const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变

# const成员函数的使用

# 动态创建数组


# 内联函数有什么优点,内联函数与宏定义的区别


# static关键字作用
1.static修饰局部变量。  
2.static修饰全局变量。  
3.static修饰普通函数。  
4.static修饰成员函数。  
5.static修饰成员变量。


# static成员函数的使用

# 右值引用

# 移动构造函数

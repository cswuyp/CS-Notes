* [数据结构与算法](#数据结构与算法)
  * [排序](#排序)
     * [各排序时间复杂度](#各排序时间复杂度)
     * [非线性时间比较类排序](#非线性时间比较类排序)
      * [交换排序](#交换排序)
        * [冒泡排序](#冒泡排序)
        * [快速排序](#快速排序)
      * [插入排序](#插入排序)
        * [简单插入排序](#简单插入排序)
        * [希尔排序](#希尔排序)
      * [选择排序](#选择排序)
        * [简单选择排序](#简单选择排序)
        * [堆排序](#堆排序)
      * [归并排序](#归并排序)
        * [二路归并排序](#二路归并排序)
        * [多路归并排序](#多路归并排序)
    * [线性时间比较类排序](#非线性时间比较类排序)
       * [计数排序](#计数排序)
        * [基数排序](#基数排序)
         * [桶排序](#桶排序)
* [十大经典排序算法动画版](https://www.cnblogs.com/onepixel/articles/7674659.html)
* [排序算法的稳定性及其意义](#排序算法的稳定性及其意义)
  
* [树和二叉树](#树和二叉树)
  * [树的定义和基本术语](#树的定义和基本术语)
  * [树的定义](#树的定义)
  * [树的基本术语](#树的基本术语)
* [二叉树](#二叉树)
  * [二叉树的定义](#二叉树的定义)
  * [二叉树的性质](#二叉树的性质)
  * [二叉树的存储结构](#二叉树的存储结构)
* [编译二叉树和线索二叉树](#遍历二叉树和线索二叉树)
  * [遍历二叉树](#遍历二叉树)
  * [线索二叉树](#线索二叉树)
* [树和森林](#树和森林)
  * [树的存储结构](#树的存储结构)
  * [森林与二叉树的转换](#森林与二叉树的转换)
  * [树和森林的遍历](#树和森林的遍历)
* [赫夫曼树及其应用](#赫夫曼树及其应用)
  * [赫夫曼树d的基本概念](#赫夫曼树的基本概念)
  * [赫夫曼树的构造算法](#赫夫曼树的构造算法)
  * [赫夫曼编码](#赫夫曼编码)
  
* [图的定义和基本术语](#图的定义和基本术语)
  * [图的定义](#图的定义)
  * [图的基本术语](#图的基本术语)
* [图的存储结构](#图的存储结构)
  * [邻接矩阵](#邻接矩阵)
  * [邻接表](#邻接表)
* [图的遍历](#图的遍历)
  * [深度优先遍历](#深度优先遍历)
  * [广度优先遍历](#广度优先遍历)
* [图的应用](#图的应用)
  * [最小生成树](#最小生成树)
  * [最短路径](#最短路径)
  * [拓扑排序](#拓扑排序)
  * [关键路径](#关键路径)
  
* [查找的基本概念](#查找的基本概念)
* [线性表的查找](#线性表的查找)
  * [顺序查找](#顺序查找)
  * [折半查找](#折半查找)
* [树表的查找](#树表的查找)
  * [二叉查找](#二叉查找)
  * [平衡二叉树](#平衡二叉树)
  * [B-树](#B-树)
  * [B+树](#B+树)
* [散列表的查找](#散列表的查找)
  * [散列表的基本概念](#散列表的基本概念)
  * [散列函数的构造方法](#散列函数的构造方法)
  * [处理冲突的方法](#处理冲突的方法)
  * [散列表的查找](#散列表的查找)
  
  
  # 数据结构与算法
  ## 排序
  ### 各排序时间复杂度
  排序方法|时间复杂度（平均）|时间复杂度（最坏）|时间复杂度（最好）|空间复杂度|稳定性
  ---|:--:|:--:|:--:|:--:|---:
  插入排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定
  希尔排序|O(n<sup>1.3</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|不稳定
  选择排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|不稳定
  堆排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(1)|不稳定
  冒泡排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定
  快速排序|O(nlog<sub>2</sub>n)|O(n<sup>2</sup>)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|不稳定
  归并排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(n)|稳定
  计数排序|O(n+k)|O(n+k)|O(n+k)|O(n+k)|稳定
  桶排序|O(n+k)|O(n<sup>2</sup>)|O(n)|O(n+k)|稳定
  基数排序|O(n*k)|O(n*k)|O(n*k)|O(n+k)|稳定


# #非线性时间比较类排序
## 交换排序
### 冒泡排序









### 快速排序

## 插入排序
### 简单插入排序
### 希尔排序




# 排序算法的稳定性及其意义
稳定性的定义：<br>
    假定在待排序的记录中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r1=r2，且r1在r2前面，排序后的序列中，r1仍然在r2前面，则称这种排序算法是稳定的；否则称为不稳定的。
    
判断方法：<br>
    对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性，而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种特定的条件下也可以变为不稳定的算法。
    
例如：对于如下的冒泡排序算法，如果将记录交换的条件改为a[j].key>=a[j+1].key，则两个相等的记录就会交换位置。
```
void BubbleSort(DataType a[],int n)
{
	int i,j,flag=1;
	DataType temp;
	for(i=1;i<n&&flag==1;i++)
	{
		flag=0;
		for(j=0;j<n-i;j++)                    
		{
			if(a[j].key>a[j+1].key)  //如果改为a[j].key>=a[j+1].key,就不稳定了
			{
				flag=1;
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
			}
		}
	}
}
```
常见算法的稳定性：<br>
堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

稳定的意义：<br>
1.如果只是简单的进行数字的排序，那么稳定性将毫无意义。

2.如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧毫无意义

3.如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧毫无意义。

4.除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序（当然如果需要不需要保持初始的排序意义，那么使用稳定性算法依旧毫无意义）。

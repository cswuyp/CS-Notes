* [面向对象的三个基本特征](#面向对象的三个基本特征)
* [虚函数的实现原理](#虚函数的实现原理)
* [怎么用C语言实现虚函数的功能](#怎么用c语言实现虚函数的功能)
* [在C++中的虚函数表是什么时期建立的](#在c中的虚函数表是什么时期建立的)
* [在C++对象内存布局](#在c对象内存布局)
* [在C++自定义的函数一定要先声明或者定义在main函数前面吗？](#在c自定义的函数一定要先声明或者定义在main函数前面吗)
* [sort函数的实现原理](#sort函数的实现原理)
* [malloc函数的实现原理](#malloc函数的实现原理)
* [new实现原理](#new实现原理)
* [new和malloc的区别](#new和malloc的区别)
* [free实现原理](#free实现原理)
* [delete实现原理](#delete实现原理)
* [realloc扩容的原理](#realloc扩容的原理)
* [拷贝构造函数](#拷贝构造函数)
* [构造函数可否为虚函数](#构造函数可否为虚函数)
* [父类的析构函数为什么要声明为虚函数](#父类的析构函数为什么要声明为虚函数)
* [描述内存分配方式以及它们的区别](#描述内存分配方式以及它们的区别)
* [#const与#define相比，有何优点](#const与define相比有何优点)
* [数组与指针的区别](#数组与指针的区别)
* [引用与指针有什么区别](#引用与指针有什么区别)
* [野指针和悬空指针](#野指针和悬空指针)
* [初始化列表初始化](#初始化列表初始化)
* [必须在构造函数初始化列表中进行初始化的数据成员有哪些](#必须在构造函数初始化列表中进行初始化的数据成员有哪些)
* [构造函数初始化](#构造函数初始化)
* [const的作用](#const的作用)
* [const成员函数的使用](#const成员函数的使用)
* [动态创建数组](#动态创建数组)
* [内联函数有什么优点,内联函数与宏定义的区别](#内联函数有什么优点内联函数与宏定义的区别)
* [static关键字作用](#static关键字作用)
* [static成员函数的使用](#static成员函数的使用)
* [static成员变量](#static成员变量)
* [从4行代码看右值引用](https://www.cnblogs.com/qicosmos/p/4283455.html)
* [移动构造函数](https://www.cnblogs.com/wuyepeng/p/9788370.html)
* [移动构造函数和移动赋值与拷贝构造函数和赋值构造函数的比较](https://www.cnblogs.com/wuyepeng/p/9787993.html)
* [重载和重写（覆盖）的区别](#重载和重写覆盖的区别)
* [lambda表达式](https://www.cnblogs.com/wuyepeng/p/9784536.html)



* [STL容器的使用](#stl容器的使用)
  * [vector](#vector)
    * [vector基础](#vector基础)
  * [map](#map)
    * [map基础](#map基础)
  * [set](#set)
    * [set基础](#set基础)
* [迭代器失效问题](https://www.cnblogs.com/wuyepeng/p/9697133.html)
* [STL里的内存池实现](#stl里的内存池实现)
* [STL里set和map是基于什么实现的，红黑树的特点](#stl里set和map是基于什么实现的红黑树的特点)

* [string类的实现](#string类的实现)
  * [普通构造函数](#普通构造函数)
  * [String的析构函数](#string的析构函数)
  * [拷贝构造函数](#拷贝构造函数)
  * [赋值函数](#赋值函数)
  * [字符串连接](#字符串连接)
  * [判断相等](#判断相等)
  * [返回长度](#返回长度)
  
  
  
* [智能指针](#智能指针)
  * [auto_ptr](#auto_ptr)
  * [unique_ptr](#unique_ptr)
  * [weak_ptr](#weak_ptr)
  * [share_ptr](#share_ptr)
* [智能指针总结](https://www.cnblogs.com/wuyepeng/p/9741241.html)

* [C++四种类型转换](#c四种类型转换)
  * [static_cast](#static_cast)
  * [dynamic_cast](#dynamic_cast)
  * [const_cast](#const_cast)
  * [reinterpret_cast](#reinterpret_cast)

# 面向对象的三个基本特征
1.封装  
简单来讲：将现实世界的事物抽象成计算机领域中的对象，对象同时具有属性和行为，这种抽象就是封装。  
封装的一个重要特性：数据隐藏，对象只对外提供与其它对象交互的必要接口，而将自身的某些属性和实现细节对外隐藏，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或者错误的使用了对象的私有部分，这样就在确保正常交互的前提下，保证了安全性。  
2.继承  
面向对象的一个重要特性是复用性，继承是实现复用性的一个重要手段，可以在不重复编写以实现的功能的前提下，对功能进行复用和拓展。  
继承概念的实现方式有两类：实现继承与接口继承  
实现继承是指直接使用基类的属性和方法而无需额外编码的能力。  
接口继承是指仅使用属性和方法的名称，但是子类必须提供实现的能力。  
3.多态  
当存在继承关系时，允许将父类对象看成和它的一个或多个子类对象等同，这样可以根据当前赋给父类对象的子类对象的具体特性以不同的方式进行运行，  
多态的几个前提  
a.要有继承关系  
b.要有方法重写  
c.要有父类引用指向子类对象  
多态的好处  
a.提高了代码的维护性（继承保证）  
b.提高了代码的扩展性（由多态保证）  
多态的限制  
不能使用子类的特有属性和行为 

多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。
动态多态实现有几个条件：  
(1) 虚函数；  
(2) 一个基类的指针或引用指向派生类的对象；  
基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。  
每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。  
虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。      
编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。  

# 虚函数的实现原理

我们可以从虚函数表和虚函数指针来了解虚函数的实现原理。  
简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。
含有虚函数的类会
http://www.cnblogs.com/malecrab/p/5572730.html

# 怎么用C语言实现虚函数的功能
参照前面C++虚函数的实现原理，可以自己添加虚函数指针和虚函数表来实现虚函数功能。  

# 在C++中的虚函数表是什么时期建立的
虚函数表是编译期确定的，虚函数表中存放的是虚函数的地址，而虚函数的地址是在编译期间就确定的所以虚函数表应该也是在编译期就确定的。 
我们在《深度探索C++对象模型》的4.2节能够找到完美的答案，具体摘抄如下：  
“表格中的virtual functions地址是如何构建起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或者替换之。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完美掌控，不需要执行期的任何介入。”

# 在C++对象内存布局
https://www.cnblogs.com/wuyepeng/p/9863296.html

# 在C++自定义的函数一定要先声明或者定义在main函数前面吗？
不一定，C++中的执行总是从main函数开始的（无论main放在什么位置），如果自定义的函数放于main函数之后则需要在main函数前声明该自定义函数，如果自定义的函数放于main函数前则不需要额外的声明，否则在main函数中调用该自定义函数时会出现无法识别。


# sort函数的实现原理
　　STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。
  
# malloc函数的实现原理
https://blog.csdn.net/hudazhe/article/details/79535220

```c++
/**内存控制块数据结构，用于管理所有的内存块
* is_available: 标志着该块是否可用。1表示可用，0表示不可用
* size: 该块的大小
**/
struct mem_control_block {
    int is_available;
    int size;
};

/**在实现malloc时要用到linux下的全局变量
*managed_memory_start：该指针指向进程的堆底，也就是堆中的第一个内存块
*last_valid_address：该指针指向进程的堆顶，也就是堆中最后一个内存块的末地址
**/
void *managed_memory_start;
void *last_valid_address;

/**malloc()功能是动态的分配一块满足参数要求的内存块
*numbytes：该参数表明要申请多大的内存空间
*返回值：函数执行结束后将返回满足参数要求的内存块首地址，要是没有分配成功则返回NULL
**/
void *malloc(size_t numbytes) {
    //游标，指向当前的内存块
    void *current_location;
    //保存当前内存块的内存控制结构
    struct mem_control_block *current_location_mcb;
    //保存满足条件的内存块的地址用于函数返回
    void *memory_location;
    memory_location = NULL;
    //计算内存块的实际大小，也就是函数参数指定的大小+内存控制块的大小
    numbytes = numbytes + sizeof(struct mem_control_block);
    //利用全局变量得到堆中的第一个内存块的地址
    current_location = managed_memory_start;

    //对堆中的内存块进行遍历，找合适的内存块
    while (current_location != last_valid_address) //检查是否遍历到堆顶了
    {
        //取得当前内存块的内存控制结构
        current_location_mcb = (struct mem_control_block*)current_location;
        //判断该块是否可用
        if (current_location_mcb->is_available)
            //检查该块大小是否满足
            if (current_location_mcb->size >= numbytes)
            {
                //满足的块将其标志为不可用
                current_location_mcb->is_available = 0;
                //得到该块的地址，结束遍历
                memory_location = current_location;
                break;
            }
        //取得下一个内存块
        current_location = current_location + current_location_mcb->size;
    }

    //在堆中已有的内存块中没有找到满足条件的内存块时执行下面的函数
    if (!memory_location)
    {
        //向操作系统申请新的内存块
        if (sbrk(numbytes) == -1)
            return NULL;//申请失败，说明系统没有可用内存
        memory_location = last_valid_address;
        last_valid_address = last_valid_address + numbytes;
        current_location_mcb = (struct mem_control_block)memory_location;
        current_location_mcb->is_available = 0;
        current_location_mcb->size = numbytes;
    }
    //到此已经得到所要的内存块，现在要做的是越过内存控制块返回内存块的首地址
    memory_location = memory_location + sizeof(struct mem_control_block);
    return memory_location;
}
```

# new实现原理
　　当我们使用关键字new在堆上动态创建一个对象时，它实际上做了三件事：（1）获得一块内存空间，（2）调用构造函数，（3）返回正确的指针。
  https://blog.csdn.net/xxpresent/article/details/53024555
  
# new和malloc的区别
1.new分配内存按照数据类型进行分配，malloc分配内存按照内存大小进行分配。  
2.new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。但是还需要注意的是，之前看过一个题说int p=new int与int p=new int()的区别，因为int属于C++内置对象，不会默认初始化，必须显示调用构造函数，但是对于自定义对象都会默认调用构造函数初始化。翻阅资源后，在C++11中两者没有区别了，自己测试的结构也都是为0；  
3.new返回的是指定对象的指针，而malloc返回的是void* 因此，malloc的返回值一般都需要进行类型转化。  
4.new是一个操作符可以重载，malloc是一个库函数。  
5.new分配的内存要用delete销毁，malloc要用free来销毁，delete销毁的时候会调用对象的析构函数，而free则不会。  
6.malloc分配的内存不够的时候，可以用realloc扩容，new没有这样的操作。  
7.new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try...catch语法，而malloc则应该判断指针的返回值。为了兼容很多C程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL  
8.new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int)* n  
9如果不够可以继续谈new和malloc的实现，空闲链表，分配方法（首次适配原则，最佳适配原则，最差适配原则，快速适配原则）delete和free的实现原理。

# free实现原理

```c++
/**free()功能是将参数指向的内存块进行释放
*firstbyte：要释放的内存块首地址
*返回值：空
**/
void free(void *firstbyte)
{
    struct mem_control_block *mcb;
    //取得该块的内存控制块的首地址
    mcb = firstbyte - sizeof(struct mem_control_block);
    //将该块标志设为可用
    mcb->is_available = 1;
    return;
}
```
# delete实现原理


# realloc扩容的原理
1、realloc() 的参数一必须是经过malloc()等动态分配函数分配的指针

2、realloc() 的参数二一定要比已分配的空间大，不然会发生数据丢失错误

3、realloc() 扩展内存时，如果当前连续内存块足够 realloc 的话，只是将p所指向的空间扩大，并返回p的指针地址。 这个时候 q 和 p 指向的地址是一样的。

4、如果当前连续内存块不够长度，再找一个足够长的地方，分配一块新的内存，q，并将 p指向的内容 copy到 q，返回 q。并将p所指向的内存空间删除。

补充说明3和4：也就是说 realloc 有时候会产生一个新的内存地址有的时候不会。所以在分配完成后，需要对其值进行判断。

当分配不成功时，返回的指针为NULL，如果不区分p和q，统一用p去接收，此时p将重新指向NULL，原来的内存将丢失，产生内存泄露。


# 拷贝构造函数
### 什么时候需要自己定义拷贝构造函数，以避免浅拷贝问题？  
一般情况下，当类中成员有指针变量，类中有动态内存分配时常常需要用户自己定义拷贝构造函数。  
### 在什么情况下系统会调用拷贝构造函数（三种情况）  
（1）用类的一个对象去初始化另一个对象  
（2）当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用  
（3）当函数的返回值是类的对象或引用时

# 构造函数可否为虚函数
构造函数不能为虚函数  
所谓虚函数就是多态情况下只执行一个，而从继承的概念来讲，总是要先构造父类对象，然后才是子类对象，如果构造函数设为虚函数，那么当你在构造父类的构造函数时就不得不显式的调用构造函数，还有一个原因就是为了防错，试想如果你在子类中一不小心重写了一个父类构造函数一样的函数，那么你的父类的构造函数将被覆盖，也即不能完成父类的构造，就会出错。

# 父类的析构函数为什么要声明为虚函数
1：每个析构函数只会清理自己的成员（成员函数前没有virtual）。

2.为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，当对象销毁时会自动调用基类的析构函数，如果此时基类的析构函数为虚函数才会再调用基类指针指向的派生类的析构函数，否则不会调用派生类的析构函数造成内存泄露。

# 描述内存分配方式以及它们的区别
（1）符号起始的区块（.bss段）：通常指的是存放程序中未初始化或者初始化为0的变量的和静态数据的区域。bss属于静态内存分配，程序结束后静态资源变量由系统自动释放。

（2）数据段：通常指存放程序中已初始化的全局变量的一块内存区域。也属于静态内存分配。

（3）代码段：有时也叫文本段，通常指的是用来存放程序执行代码（包含类成员函数和全局函数及其他函数代码），这部分区域的大小在程序运行前就已经确定，也有可能包含一些只读的常数变量，例如字符串变量。

（4）堆（heap）:用于存放进程运行中被动态分配的内存段，大小不固定。当进程调用malloc或者new等函数时，新分配的内存就被动态添加到堆上（堆被扩张），当使用free或者delete等函数释放内存时，被释放的内存从堆中被删除。需要注意的是，它与数据结构中的堆是两回事，它的分配方式类似于链表。

（5）栈（stack）:存放程序临时创建的局部变量，不包括static声明的变量，static意味着在数据段中存放。除此之外，当函数被调用时，其参数也会被压到栈中，并在调用结束后，函数的返回值也会被放到栈中。栈由编译器自动释放。其操作方式类似于数据结构中的栈。栈内存分配运算内置于处理器的指令集中，一般使用寄存器来存取，效率很高，但是分配的内存容量有限。

# #const与#define相比，有何优点
1.const可以明确指定类型，而宏定义没有数据类型。编译器可以对const进行类型安全检查，而宏定义只是简单的字符替换，有时候会产生意想不到的错误。

2.可以使用C++的作用域规则将定义限制在特定的函数或是文件中。在默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在C++看来，全局const定义就像使用了static说明符一样。


# 数组与指针的区别
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

(1)修改内容上的差别
```
char a[] = “hello”;

a[0] = ‘X’;

char *p = “world”; // 注意p 指向常量字符串

p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
```
(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
```
char a[] = "hello world";

char *p = a;

cout<< sizeof(a) << endl; // 12 字节

cout<< sizeof(p) << endl; // 4 字节

计算数组和指针的内存容量

void Func(char a[100])

{

cout<< sizeof(a) << endl; // 4 字节而不是100 字节

}
```
# 引用与指针有什么区别
1.指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问。  
2.指针可以改变地址，从而改变所指的对象，而引用一经初始化就不可更改  
3.引用在定义时必须初始化，而指针则不需要。  
4.指针有指向常量的指针和指针常量，而引用没有常量引用    
5.指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全很多但是比较死板。  


# 野指针和悬空指针
空悬指针是这样一种指针：指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。

野指针是这样一种指针：未初始化的指针，其指针内容为一个垃圾数。 （一般我们定义一个指针时会初始化为NULL或者直接指向所要指向的变量地址，但是如果我们没有指向NULL或者变量地址就对指针进行使用，则指针指向的内存地址是随机的）。存在野指针是一个严重的错误。
```c++
int main() {
    int *p; // 指针未初始化，此时 p 为野指针
    int *pi = nullptr;
 
    {
        int i = 6;
        pi = &i; // 此时 pi 指向一个正常的地址
        *pi = 8; // ok
    }  
 
    *pi = 6; // 由于 pi 指向的变量 i 已经销毁，此时 pi 即成了悬空指针
 
    return 0;
}
```

# 初始化列表初始化
1.类成员中存在常量，如const int a,只能用初始化不能复制

2.类成员中存在引用，同样只能使用初始化不能赋值。

3.提高效率

关于提高效率在《Effective C++》条款12 尽量使用初始化而不要在构造函数里赋值，是这样说的：
```c++
template<class T>
class NamedPtr {
public:
    NamedPtr(const string& initName, T *initPtr);
    ...
private:
    const string& name; // 必须通过成员初始化列表
                        // 进行初始化
    T * const ptr; // 必须通过成员初始化列表
                   // 进行初始化
};
```
前面最初的类模板不包含 const 和引用成员。即使这样，用成员初始化列表还是比在构造函数里赋值要好。这次的原因在于效率。当使用成员初始化列表时，只有一个 string 成员函数被调用。而在构造函数里赋值时，将有两个被调用。为了理解为什么，请看在声明 NamedPtr<T>对象时都发生了些什么。

对象的创建分两步：
1. 数据成员初始化。
2. 执行被调用构造函数体内的动作。

（对有基类的对象来说，基类的成员初始化和构造函数体的执行发生在派生类的成员初始化和构造函数体的执行之前）

对 NamedPtr 类来说，这意味着 string 对象 name 的构造函数总是在程序执行到 NamedPtr 的构造函数体之前就已经被调用了。问题只在于：string 的哪个构造函数会被调用？

这取决于 NamedPtr 类的成员初始化列表。如果没有为 name 指定初始化参数，string 的缺省构造函数会被调用。当在 NamedPtr 的构造函数里对 name执行赋值时，会对 name 调用 operator=函数。这样总共有两次对 string 的成员函数的调用：一次是缺省构造函数，另一次是赋值。相反，如果用一个成员初始化列表来指定 name 必须用 initName 来初始化，name 就会通过拷贝构造函数以仅一个函数调用的代价被初始化。即使是一个很简单的 string 类型，不必要的函数调用也会造成很高的代价。随着类越来越大，越来越复杂，它们的构造函数也越来越大而复杂，那么对象创建的代价也越来越高。养成尽可能使用成员初始化列表的习惯，不但可以满足 const 和引用成员初始化的要求，还可以大大减少低效地初始化数据成员的机会。


# 必须在构造函数初始化列表中进行初始化的数据成员有哪些
（1）常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面  
（2）引用成员，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面  
（3）没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
# 构造函数初始化


# const的作用
1.const修饰全局变量  
2.const修饰局部变量  
3.const修饰指针，const int*  
4.const修饰指针指向的对象，int * const;    
5.const修饰引用该做形参  
6.const修饰成员变量，必须在构造函数列表中初始化  
7.const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变

# const成员函数的使用
编译器会自动给每一个函数加一个this指针。在一个类的函数后面加上const后，就表明这个函数是不能改变类的成员变量的（加了mutable修饰的除外,后面有讲）。实际上，也就是对这个this指针加上了const修饰。

在C++中，只有被声明为const的成员函数才能被一个const类对象调用。

1）const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；

2）非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；

3）作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const 成员函数。

# 动态创建数组
用到的头文件：# include <stdlib.h>
```c++
int n = 10;
int *p = (int*) malloc (n * sizeof(int));//建立可以存放是个int型数据的数组
```
解释：  
1、malloc()函数的形参是要分配的字节数，注意是字节数，不是单元数。

2、malloc函数返回的是一个无类型的首地址，因此必须在malloc函数前加上类型强转，转换为自己需要的数据类型

3、因为malloc函数只负责分配内存，所以我们需要自己定义相应的类型变量来接收malloc分配的内存，注意malloc函数返回的      是分配内存的首地址，所以接收的变量也应该是相应的指针类型

# 内联函数有什么优点,内联函数与宏定义的区别
1.宏定义在预编译的时候就会进行宏替换  
2.内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译（内联是给编译器的一个建议编译器可以不听）    
3.内联函数相对比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。  
4.使用宏定义函数要特别注意给所有单元都加上括号，否则很容易出错

# static关键字作用
1.static修饰局部变量。  
2.static修饰全局变量。  
3.static修饰普通函数。  
4.static修饰成员函数。  
5.static修饰成员变量。

# static成员函数的使用

1.函数的行为对所有派生类都一致时，可以声明为静态。

2.因为静态成员函数只跟类有关跟类的实例无关，因此它不需要this指针

3.静态成员函数由于是不与任何对象相关联的，所以是没有this指针的。从这里也可以知道静态成员函数无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其他的静态成员函数。即静态成员函数不能访问非静态成员（非静态成员函数或者非静态成员变量），但是非静态成员可以直接访问静态成员。

```c++
#include<iostream>
using namespace std;
class MyClass
{
public:
    MyClass(int a, int b, int c);
    static  void func();
    void printf()
    {
        cout << sum << endl;
    }
private:
    int a, b, c;
    static int sum;//静态成员变量的声明
};
int MyClass::sum = 0;//静态成员变量必须在类外定义和初始化
MyClass::MyClass(int a, int b, int c)
{
    this->a = a;
    this->b = b;
    this->c = c;
    sum += a + b + c;
}
void MyClass::func()
{
    cout << sum << endl;
}
int main()
{
    MyClass A(1, 2, 3);
    A.func();
    A.printf();
    MyClass B(4, 5, 6);
    B.func();
    B.printf();
    //MyClass::printf();//错误，非静态成员函数必须与特定对象相对
    MyClass::func();//静态成员函数是类中的所有对象共享的，并不但属于特定对象
    return 0;
}
```

# static成员变量
1.静态成员变量是整个类的实例共享的

2.静态成员变量存储在静态存储区/全局存储局，而非静态成员变量需要实例化才会分配内存。

3.静态成员变量只能在类内声明在类外定义和初始化。

为什么静态成员变量不能在类内定义？

答：为了防止重复定义，静态成员变量是类的所有实例共享的，只需要定义一次就可以，如果在类内定义则每实例化一次类都会重新定义一次静态成员变量，这会产生重复定义。

静态成员不能访问非静态成员，非静态成员可以直接访问类中的静态成员。

# STL容器的使用
STL是一个标准模板库，是一个高效的C++程序库。

# vector
vector是线性容器，它的元素严格按照线性序列排序，和动态数组很相似。和数组类似的是，它的元素存储在一块连续的存储空间中，这也意味着不仅可以使用迭代器(iterator)访问元素，还可以使用指针的偏移方式访问。和常规数组不一样的是，vector能够自动存储元素，可以自动增长或缩小存储空间。  

vector的优点如下所述：  
（1）可以使用下标访问个别的元素。  
（2）迭代器可以按照不同的方式遍历容器。  
（3）可以在容器的末尾增加和删除元素。  
和数组相比，虽然容器在自动处理容量的大小时会消耗更多的内存，但是容器能提供和数组一样的性能，而且能更好地调整存储空间的大小。  

和其他标准的顺序容器相比，vector能更有效访问容器内的元素和在末尾添加和删除元素，而在其他位置添加和删除元素，vector则不及其他顺序容器，在迭代器和 引用也不比lists支持的好。

容器的大小和容器的容量是有区别的，大小是指元素的个数，容量是分配的内存大小，容量一般不小于容器的大小。vector::size()返回容器的大小，vector::capacity()返回容量值，容量多于容器大小的部分用于以防容器大小的增加使用。每次重新分配内存都会很影响程序的性能，所以一般分配的容量都大于容器的大小，若要自己指定分配的容量大小，则可以使用vector::reserve()，但是规定的值要大于size()值。

# vector基础
#### vector的查增删
##### vector的初始化和遍历
vector<T>v1|v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
---|:--:
vector<T>v2(v1)|v2中包含有v1所有元素的副本
vector<T>v2=v1|等价于v2(v1)，v2中包含有v1所有元素的副本
vector<T>v3(n,val)|v3包含了n个重复的元素，每个元素的值都是val
vector<T>v4(n)|v4包含了n个重复地执行了值初始化的对象
vector<T>v5{a,b,c...}|v5包含了初始值个数的元素，每个元素被 赋予相应的初始值
vector<T>v5={a,b,c...}|等价于v5{a,b,c...}

vector的遍历有for(int i=0;i<a.size();++i)、for(iter=vec.begin();iter!=vec.end();iter++)、for(auto it:vec)

##### vector中存放结构体时的排序
```c++
#include<algorithm>
#include<vector>
#include<iostream>
using namespace std;

typedef struct rect{
    int id;
    int length;
    int width;
    bool operator< (const rect &a) const{
        if(id!=a.id)
            return id<a.id;
        else{
            if(length!=a.length)
                return length<a.length;
            else
                return width<a.width;
        }
    }
}Rect;

int main(){
    vector<Rect> vec;
    Rect rect;
    rect.id=2;
    rect.length=3;
    rect.width=4;
    vec.push_back(rect);
    rect.id=1;
    rect.length=2;
    rect.width=3;
    vec.push_back(rect);
    vector<Rect>::iterator it=vec.begin();
	cout<<(*it).id<<' '<<(*it).length<<' '<<(*it).width<<endl;  
	sort(vec.begin(),vec.end());
    cout<<(*it).id<<' '<<(*it).length<<' '<<(*it).width<<endl;  
    return 0;
}
```
程序执行结果是：  
2 3 4  
1 2 3  

##### 结构体外定义比较函数
除了重载结构体里的rect，也可以在结构体外定义一个函数来进行排序。
```c++
#include<algorithm>
#include<vector>
#include<iostream>
using namespace std;

typedef struct rect{
    int id;
    int length;
    int width;
}Rect;
int cmp(Rect a,Rect b){
	if(a.id!=b.id)
		return a.id<b.id;
    else{
		if(a.length!=b.length)
            return a.length<b.length;
        else
            return a.width<b.width;
    }
}

int main(){
    vector<Rect> vec;
    Rect rect;
    rect.id=2;
    rect.length=3;
    rect.width=4;
    vec.push_back(rect);
    rect.id=1;
    rect.length=2;
    rect.width=3;
    vec.push_back(rect);
    vector<Rect>::iterator it=vec.begin();
    cout<<(*it).id<<' '<<(*it).length<<' '<<(*it).width<<endl;  
    sort(vec.begin(),vec.end(),cmp);
    cout<<(*it).id<<' '<<(*it).length<<' '<<(*it).width<<endl;  
    return 0;
}

```
程序的执行结果是：  
2 3 4  
1 2 3  
上面两个程序不同的是，后者没有对结构体进行重载，而是在结构体外定义一个比较函数，另外sort的调用方式也不相同，后者加了一个比较函数作为第3个参数，二者均可以实现对vec的排序。

##### vector的查找
使用find函数在vector中进行查找
```c++
#include <iostream>
# include<algorithm>
#include<vector>
using namespace std;
int main()
{
	vector<int> vec{ 1,2,3,4,5 };
	vector<int>::iterator iter = find(vec.begin(), vec.end(), 3);
	if (iter == vec.end())
	{
		cout << "Not Find" << endl;
	}
	else
	{
		cout << "Found" << endl;
		return 0;
	}
}
```
##### vector的删除
vector中的删除，可以有erase或pop_back()。erase可以删除指定元素或指定位置的元素，而pop_back只能去掉数组的最后一个数据

erase的函数原型有以下两种形式：  
iterator erase(iterator position)  
iterator erase(iterator first,iterator last)  
假设有这样的程序:  
```c++
vector<int>vec{1,2,3,4,5};
for (vector<int>::iterator iter = vec.begin(); iter != vec.end(); iter++)
{
	if (*iter == 3)
	{
		vec.erase(iter);
	}
}
```
乍一看这段代码很正常，其实这里面隐藏着一个很严重的错误，当vec.erase()语句执行了之后，iter就变成一个野指针，对一个野指针进行++iter操作肯定是会出错的。  
查看MSDN，对于erase的返回值是这样描述的:An iterator that designates the first element remaining beyond any elements removed,or a pointer to the end of the vector if no such element exists,于是改代码：
```c++
for (vector<int>::iterator iter = vec.begin(); iter != vec.end(); iter++)
{
	if (*iter == 3)
	{
		iter=vec.erase(iter);
	}
}
```
这段代码也是错误的：（1）无法删除两个连续的3，（2）当数字3位于vector最后位置的时候，也会出错（在vec.end()上执行++操作）。正确的代码如下：  
使用erase删除vector中某个元素  
```c++
#include <iostream>
# include<algorithm>
#include<vector>
using namespace std;
int main()
{
	vector<int>vec{ 1,2,3,3,4,5 };
	vector<int>::iterator iter = vec.begin();
	for (; iter != vec.end();)
	{
		if (*iter == 3)
		{
			iter = vec.erase(iter);
		}
		else
		{
			++iter;
		}
	}
	for (iter = vec.begin(); iter != vec.end(); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;
	return 0;
}
```
for语句条件里面删除元素时，返回值指向已删除元素的下一个位置，不是删除元素时则直接进行++操作。  
使用vec.erase(vec.begin()+i,vec.end()+j)语句则是删除区间[i,j-1]间的元素。  
而pop_back只能去掉数组的最后一个元素。

##### vector的增加
vector中的增加，可以有insert和push_back。insert是插入元素到某个位置中，push_back是在最后添加一个元素。

insert的函数原型有以下3种形式：  
```c++
iterator insert(iterator loc,const TYPE &val);//在指定位置loc前插入值为val的元素，返回指向这个元素的迭代器  

void insert(iterator loc,size_type num,const TYPE &val);//在指定位置loc前插入num个值为val的元素  

void insert(iterator loc,input_iterator start,input_iterator end);//在指定位置loc前插入区间[start,end)的所有元素

```
vector的查增删用法举例
```c++
#include <iostream>
#include<algorithm>
#include<vector>
using namespace std;
void print(vector<int>v)
{
	vector<int>::iterator iter = v.begin();
	for (; iter != v.end(); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;
}
int main()
{
	vector<int>v;//现在容器中有0个元素
	int values[] = { 1,3,5,7 };
	v.insert(v.end(), values + 1, values + 3);//现在容器中有2个元素分别为：3，5
	print(v);
	v.push_back(9);//现在容器中有3个元素分别为3，5，9
	print(v);
	v.erase(v.begin() + 1);//现在容器中2个元素分别为3，9
	print(v);
	v.insert(v.begin() + 1, 4);//现在容器中有3个元素分别为3，4，9
	print(v);
	v.insert(v.end() - 1, 4, 6);//现在容器中有7个元素分别为3，4，6，6，6，6，9
	print(v);
	v.erase(v.begin() + 1, v.begin() + 3);//现在容器中有5个元素分别为3，6，6，6，9
	print(v);
	v.pop_back();//现在容器中有4个元素分别为3，6，6，6
	print(v);
	v.clear();//现在容器中有0个元素
	print(v);
	if (true == v.empty())//如果容器为空则输出null
	{
		cout << "null" << endl;
	}
	return 0;
}
```
注意  
v.insert(v.end(),values+1,values+3);  
就是将数组第2个元素和第三个元素的值插入到v.end()位置中，因为此时v还是空的，所以这里也是往空vector里插入了两个元素。这里只插入了两个元素，而没有插入3个元素

##### vector的内存管理与效率
1.使用reserve()函数提前设定容量大小  
　　关于STL容器，最令人称赞的特性之一就是只要不超过他们的最大值，就可以自动增长到足以容纳用户放进去的数据的大小。（这个最大容量值，只要调用名加max_size的成员函数就可以获得），对于vector和string，如果需要更多的空间，就会以类似realloc的思想来增长大小。vector容器支持随机访问，因此为了提高效率，它内部是使用动态数组的方式实现的。在通过reserve()函数来申请特定大小的内存空间时候总是按指数边界来增长其内部缓冲区。当进行insert或push_back等增加元素的操作时，如果此时动态数组的内存不够用，就要动态的的重新分配当前大小的1.5——2倍的新内存区，再把愿数组的内容复制过去。所以，在一般情况下，其访问速度同一般的数组相比，只有在重新分配 发生时，其性能才会下降。进行pop_back操作时，capacity并不会因为vector容器里的元素减少而有所下降，还会维持操作之前的大小。对于vector容器来数，如果有大量的数据需要进行push_back()，应当使用reserve()函数提前设定其容量大小，否则会出现许多次容量扩充操作，导致效率低下。
  
　　reserve()成员函数允许开发者最小化必须进行的重新分配次数，因而可以避免真分配的开销和迭代器、指针、引用失效。但在解释reserve为什么可以那么做之前需要先简要介绍有时候令人困惑的4个相关成员函数，如下所述。在标准容器中，只有vector和string提供了所有这些函数。
  
　　（1）size()可以获得容器中有多少元素，但不能获得容器为它容纳的元素分配的内存大小。  
　　（2）capacity()可以获得容器在它已经分配的内存中可以容纳多少元素。那是容器在那块内存中总共可以容纳多少元素，而不是还可以容纳多少元素。如果想知道一个vector或string中有多少没有被占用的内存，则必须从capacity()中减去size()。如果size和capacity返回同样的值，容器中就没有剩余空间了，而下一次插入（通过insert或push_back等）会引发上面的重新步骤。  
　　（3）resize(Container::size_type n)用来强制把容器改为容纳n个元素。调用resize函数之后，size函数将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入之前会进行重新分配。  
　　（4）reserve（Container::size_type n）强制容器把它的容量改为不小于n，提供的n不小于当前所需的大小。因为容量需要增加，这一般会强迫进行一次重新分配。如果n小于当前容量，vector会忽略它，则这个调用什么都不做，string可能把它的容量减少为size()和n中大的数，但string的大小没有变化。  
　　综上所述，只要有元素需要插入而且容器的容量不足时就会发生重新分配（包括他们维护的原始内存分配和回收，对象的拷贝和析构和迭代器、指针和引用的失效）。所以，避免重新分配的关键是使用reserve尽快把容器的容量设置为足够大，最好在容器被构造之后立刻进行。

例如，假定想建立一个容纳1-1000值的vector<int>，若不使用reserve,则可以像这样来做:   
```c++
vector<int>v;
for(int i=1;i<=1000;i++)
{
	v.push_back(i);			
}
```
在大多数STL实现中，这段代码在循环过程中将会导致2-10次重新分配。（10这个数没什么奇怪的。记住vector在重新分配发生时一般把容量翻倍，而1000约等于2<sup>10</sup>。）  
把代码改为使用reserve，如下所示：  
```c++
vector<int>v;
v.reserve(1000);
for(int i=1;i<=1000;i++)
{
	v.push_back(i);
}
```
在这循环中不会发生重新分配。  
由于大小和容量之间的关系可以预言什么时候插入将引起vector或string执行重新分配，而且，可以预言什么时候插入会使指向容器中的迭代器、指针和引用失效。例如，给出这段代码：
```c++
string s;
...
if(s.zize()<s.capacity())
{
	s.push_back('x');	
}
```
push_back的调用不会使指向这个string中的迭代器、指针或引用失效，因为string的容量保证大于它的大小，如果不是执行push_back，代码在string的任意位置进行一个insert，仍然可以保证在插入期间没有重新分配，但是，与伴随string插入时迭代器失效的一般规则一致，所有从插入位置到string结尾的迭代器、指针、引用将失效。

通常有两种情况使用reserve来避免不必要的重新分配。第一种可用的情况是当知道有多少元素将最后出现在容器中时，就像上面的vector代码，就可以提前reserve适当数量的空间，第二种情况是保留可能需要的最大空间，然后添加完全部数据后，再修整掉任何多余的容量。

##### 使用“交换技巧”来修整vector过剩空间/内存

有一种方法来把它从曾经最大的容量减少到它现在需要的容量，这样的方法常常被称为“收缩到合适”（shrink to fit）。该方法只需一条语句：vector<int>(vec).swap(vec)。

表达式vector<int>(vec)表示建立一个临时vector，它是vec的一份拷贝。但是，vector的拷贝构造函数只分配拷贝的元素需要的内存，所以这个临时vector没有多余的容量。然后临时vector和vec交换数据完成，但vec只有临时变量的修整过的容量，而这个临时变量则持有了曾经在vec中的没用到的过剩容量，在这个语句结尾处，临时vector被销毁，以释放以前vec使用的内存，收缩都合适的大小。

##### 用swap方法强行释放vector所占内存
```c++
template<class T>void ClearVector(vector<T>&v)
{
	vector<T>temp;
	vtTemp.swap(v);
}
vector<int>v{1,2,3,4};
vector<int>().swap(v);
/*或者v.swap(vector<int>());*/
/*或者{vector<int>tmp=v;v.swap(tmp);}*/  //加大括号{}是让tmp退出{}时自动析构
```
##### Vector内存管理成员函数的行为测试
```c++
#include <iostream>
#include <vector>
using namespace std;
int main(){
    vector<int> iVec;
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
	
	/*1个元素,容器容量为1*/
    iVec.push_back(1);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
	
	/*2个元素,容器容量为2*/
    iVec.push_back(2);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
	
	/*3个元素,容器容量为4*/
    iVec.push_back(3);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
	
    /*4个元素,容器容量为4*/
    iVec.push_back(4);
	cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
	
    /*5个元素,容器容量为8*/	
    iVec.push_back(5);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
	
    /*6个元素,容器容量为8*/	
    iVec.push_back(6);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;

    /*7个元素,容器容量为8*/	
    iVec.push_back(7);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl; 

    /*8个元素， 容器容量为8*/	
    iVec.push_back(8);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;

    /*9个元素， 容器容量为16*/	
    iVec.push_back(9);
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;

    /* vs2005/8 容量增长不是翻倍的，如 
    9个元素   容量9 
    10个元素 容量13 */

    /* 测试effective stl中的特殊的交换 swap() */
    cout<<"容器大小:"<<iVec.size()<<"容量:"<<iVec.capacity()<<endl;
    vector<int>(iVec).swap(iVec);

    cout<<"临时的vector<int>对象的大小为:"<<(vector<int>(iVec)).size()<<endl;
    cout<<"临时的vector<int>对象的容量为: " <<(vector<int>(iVec)).capacity()<<endl;
    cout<<"交换后,当前vector的大小为:"<<iVec.size()<<endl;
    cout<<"交换后,当前vector的容量为:"<< iVec.capacity()<<endl;

    return 0;
}

```
上面程序展示了vector在不同情况下占用内存空间的大小情况 ：vector是按照容器现在容量的一倍进行增长。vector容器分配的是一块连续的内存空间，每次容器的增长，并不是在原有连续的内存空间后再进行简单的叠加，而是重新申请一块更大的新内存，并把现有容器中的元素逐个复制过去，同时销毁旧的内存，这时原有指向旧内存空间的迭代器已经失效，所以当操作容器时，迭代器要及时更新。

#### Vector类的简单实现

实现一个vector  
```c++
#include<algorithm>
#include<iostream>
#include <assert.h>
using namespace std;
template<typename T>
class myVector
{
private:
	/*walk length*/ 
	/*myVector each time increase space length*/ 
	#define WALK_LENGTH 64;

public:
	/*default constructor*/ 
	myVector():array(0),theSize(0),theCapacity(0){	}
	myVector(const T& t,unsigned int n):array(0),theSize(0),theCapacity(0){
		while(n--){
			push_back(t);
		}
	}

	/*copy constructor*/ 
	myVector(const myVector<T>& other):array(0),theSize(0),theCapacity(0){
		*this = other;
	}

	/*= operator*/ 
	myVector<T>& operator =(myVector<T>& other){
		if(this == &other)
			return *this;
		clear();
		theSize = other.size();
		theCapacity = other.capacity();
		array = new T[theCapacity];
		for(unsigned int i = 0 ;i<theSize;++i)
		{
			array[i] = other[i];
		}
		return *this;
	}

	/*destructor*/ 
	~myVector(){
		clear();
	}

	/*the pos must be less than myVector.size();*/ 
	T& operator[](unsigned int pos){
		assert(pos<theSize);
		return array[pos];
	}

	/*element theSize*/ 
	unsigned int size(){
		return theSize;
	}

	/*alloc theSize*/ 
	unsigned int capacity(){
		return theCapacity;
	}
	
	/*is  empty*/ 
	bool empty(){
		return theSize == 0;
	}

	/*clear myVector*/ 
	void clear(){
		deallocator(array);
		array = 0;
		theSize = 0;
		theCapacity = 0;
	}

	/*adds an element in the back of myVector*/  
	void push_back(const T& t){
		insert_after(theSize-1,t);
	}

	/*adds an element int the front of myVector*/ 
	void push_front(const T& t){
		insert_before(0,t);
	}

	/*inserts an element after the pos*/ 
	/*the pos must be in [0,theSize);*/ 
	void insert_after(int pos,const T& t){
		insert_before(pos+1,t);
	}

	/*inserts an element before the pos*/ 
	/*the pos must be less than the myVector.size()*/ 
	void insert_before(int pos,const T& t){
		if(theSize==theCapacity){
			T* oldArray = array;
			theCapacity += WALK_LENGTH; 
			array = allocator(theCapacity);
			/*memcpy(array,oldArray,theSize*sizeof(T)):*/ 
			for(unsigned int i = 0 ;i<theSize;++i){
				array[i] = oldArray[i];
			}
			deallocator(oldArray);
		}

		for(int i = (int)theSize++;i>pos;--i){
			array[i] = array[i-1];
		}
		array[pos] = t;
	}

	/*erases an element in the pos;*/ 
	/*pos must be in [0,theSize);*/ 
	void erase(unsigned int pos){
		if(pos<theSize){
			--theSize;
			for(unsigned int i = pos;i<theSize;++i){
				array[i] = array[i+1];
			}
		}
	}

private:
	T*  allocator(unsigned int size){
		return new T[size];
	}

	void deallocator(T* arr){
		if(arr)
			delete[] arr;
	}
private:
	T*				array;
	unsigned int	theSize;
	unsigned int	theCapacity;
};

void printfVector(myVector<int>& vector1){
	for(unsigned int i = 0 ; i < vector1.size();++i){
		cout<<vector1[i]<<",";
	}
	cout<<"alloc size = "<<vector1.capacity()<<",size = "<<vector1.size()<<endl;
}

int main(){
	myVector<int> myVector1;
	myVector<int> myVector2(0,10);
	myVector2.push_front(1);
	myVector2.erase(11);
	printfVector(myVector2);
	myVector1.push_back(2);
	myVector1.push_front(1);
	printfVector(myVector1);
	myVector1.insert_after(1,3);
	printfVector(myVector1);

	myVector2 = myVector1;
	myVector2.insert_before(0,0);
	myVector2.insert_before(1,-1);
	printfVector(myVector2);
    return 0;
}
```
程序执行结果是：  
1，0，，0，0，0，0，0，0，0，0，0，alloc size=64,siz=11  
1,2,alloc size =64,size=2  
1,2,3,alloc size=64,size=3  
0,-1,1,2,3,alloc size=64,size=5

STL库中vector是一个自动管理的动态数组，只要明白vector的类型是一个数组，至于怎么去实现它其实不难。在上面的代码中选择了一种简单的方式去实现它，定义一个步长WALK_LENGTH，在数组空间不够时，再重新申请长度为theCapacity+WALK_LENGTH的内存，这样就避免了每次当myVector元素增加的时候，需要去重新申请空间的问题，当然不好的地方就是会浪费一定的空间，但是时间效率上会提高很多。因为vector可以支持下标访问，所以就不用单独构造一个iterator，从而提高效率。  
myVector拥有3个成员变量：元素的个数theSize、容量theCapacity和一个指针数组array。  
默认构造函数里，把元素的个数theSize、容量theCapacity都赋值为0，数组赋值为空，代码如下：  
```c++
myVector():array(0),theSize(0),theCapacity(0){}
```
用几个相同的值赋值给myVector，那应该是逐个添加的：  
```c++
myVector(const T& t,unsigned int n):array(0),theSize(0),theCapacity(0)
{
	while(n--)
	{
		push_back(t);
	}
}
```
进行重载:
```c++
myVector<T>& operator=(myVector<T>& other)
{
	if(this==&other)
	{
		return *this;
	}	
	clear();
	theSize=other.size();
	theCapacity=other.capacity();
	array=new T(theCapacity);
	for(unsigned int i=0;i<theSize();i++)
	{
		array[i]=other[i];
	}
	return *this;
}
```
如果参数与本myVector相同，那就无需赋值了；不相同时才需要赋值，并需要分别对3个成本变量进行赋值，元素个数、容量大小和数组内容。

析构函数里直接调用clear函数，如下所示:  
```c++
~myVector()
{
	clear();
}
```
用下标的方式访问myVector中的元素，其实就是访问数组array中的元素，注意下标必须小于元素个数，如下所示：  
```c++
T& operator[](unsigned int pos)
{
	assert(pos<theSize);
	return array[pos];
}
```
获得元素个数和容器大小，直接返回成员变量即可，如下所示：  
```c++
/*element theSize*/
unsigned int size()
{
	return theSize;
}
/*alloc theSize*/
unsigned int capacity()
{
	return theCapacity;
}
```
判断myVector是否为空，直接判断元素个数是否等于0即可，如下所示：  
```c++
bool empty()
{
	return theSize==0;
}
```
清空myVector中的元素，需要删除掉数组指针，并把元素个数和容量大小都置0，如下所示：  
```c++
void clear()
{
	deallocator(array);
	array=0;
	theSize=0;
	theCapacity=0;
}
```
push_back、push_front都可以归根于insert，在哪个位置插入 ，如下所示：  
```c++
/*adds an element in the back of myVector*/  
	void push_back(const T& t){
		insert_after(theSize-1,t);
	}

	/*adds an element int the front of myVector*/ 
	void push_front(const T& t){
		insert_before(0,t);
	}

	/*inserts an element after the pos*/ 
	/*the pos must be in [0,theSize);*/ 
	void insert_after(int pos,const T& t){
		insert_before(pos+1,t);
	}

	/*inserts an element before the pos*/ 
	/*the pos must be less than the myVector.size()*/ 
	void insert_before(int pos,const T& t){
		if(theSize==theCapacity){
			T* oldArray = array;
			theCapacity += WALK_LENGTH; 
			array = allocator(theCapacity);
			/*memcpy(array,oldArray,theSize*sizeof(T)):*/ 
			for(unsigned int i = 0 ;i<theSize;++i){
				array[i] = oldArray[i];
			}
			deallocator(oldArray);
		}

		for(int i = (int)theSize++;i>pos;--i){
			array[i] = array[i-1];
		}
		array[pos] = t;
	}
```
myVector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。删除某个元素，则要把这个元素后面的都往前挪，并把元素个数-1，如下所示：  
```c++
/*erases an element in the pos;*/ 
/*pos must be in [0,theSize);*/ 
void erase(unsigned int pos){
	if(pos<theSize){
		--theSize;
		for(unsigned int i = pos;i<theSize;++i){
			array[i] = array[i+1];
		}
	}
}
```
通过分析代码，可以发现vector的特点，如下所述。
（1）随即访问元素效率跟高。  
（2）push_back的效率也会很高。  
（3）push_front的效率非常低，不建议使用。  
（4）insert需要把插入位置以后的元素全部后移，效率比较低，不建议使用。  
（5）erase需要把删除位置后面的元素全部前移，效率比较低，不建议使用。  
（6）当内存不够时，需要重新申请内存，再把以前的元素复制过来，效率也比较低。

# map
#### map的本质
map本质是一类关联式容器，属于模板类关联的本质在于元素的值与某个特定的键相关联，而非通过元素在数组中的位置来获取。它的特点是增加和删除节点对迭代器的影响还很小，出了操作节点，对其他的节点都没有什么影响。对于迭代器来说，不可以修改键值，只能修改其对应的实值。map内部数据的组织，map内部自建一棵红黑树（一种非严格意义上的平衡二叉树），这棵树具对数据自动排序的功能，所以在map内部所有的数据都是有序的。  

#### map的功能
自动建立Key-value的一一对应关系。  
根据Key值快速查找记录，查找的复杂度基本是Log(N)，即如果有1000个记录，最多查找10次，1000000个记录，最多查找20次。除此之外，还有快速插入排序Key-value记录快速删除记录、根据Key修改values记录，遍历所有记录等功能。


# map基础
### map的查增删
pair的应用

pair是将2个数据组合成一个数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。

1.map的插入
map的插入有3种方式:用insert函数插入pair数据、用insert函数插入value_type数据和用数组方式插入数据。
```c++
#include<map>
#include<string>
#include<iostream>>
using namespace std;
int main()
{
	map<int,string>mapStudent;
	mapStudent.insert(pair<int,string>(1,"student_one"));
	mapStudent.insert(pair<int,string>(2,"student_two"));
	mapStudent.insert(pair<int,string>(3,"student_three"));
	map<int,string>::iterator iter;
	for(iter=mapStudent.begin();iter!=mapStudent.end();iter++)
	{
		cout<<iter->first<<" "<<iter->second<<endl;
	}
	return 0;
}
```
程序的执行结果是:  
1 student_one  
2 student_two  
3 student_three  
声明了一个Key为int类型，value为string类型的map，用insert函数插入pair数据，且需要在insert的参数中将(1,"student_one")转换为pair数据再进行插入。

##### 用insert函数插入value_type数据
```c++
#include <map>
#include <string>
#include <iostream>
using namespace std;
int main()
{
    map<int, string> mapStudent;
    mapStudent.insert(map<int, string>::value_type (1,"student_one"));
    mapStudent.insert(map<int, string>::value_type (2,"student_two"));
    mapStudent.insert(map<int, string>::value_type (3,"student_three"));
    map<int, string>::iterator  iter;
    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++){
       cout<<iter->first<<" "<<iter->second<<endl;
    }
	return 0;
}

```
程序的执行结果是：  
1 student_one  
2 student_two  
3 student_three  
声明了一个Key为int类型，value为string类型的map，用insert函数插入value_type数据，且需要在insert的参数中将(1,"student_one")转换为map<int,string>::value_type数据再进行插入。  

##### map中用数组方式插入数据
```c++
#include<map>
#include<string>
#include<iostream>
using namespace std;
int main()
{
	map<int,string>mapStudent;
	mapStudent[1]="student_one";
	mapStudent[2]="student_two";
	mapStudent[3]="student_three";
	map<int,string>::iterator iter;
	for(iter=mapStudent.begin();iter!=mapStudent.end();iter++)
	{
		cout<<iter->first<<" "<<iter->second<<endl;
	}
	return 0;
}
```
程序的执行结果是：  
1 student_one  
2 student_two  
3 student_three  

上述程序中展示了用数组方式在map插入数据，和数组访问一样，有下标，直接赋值。以上3种用法，虽然都可以实现数据的插入，但是他们是有区别的，当然了第一种和第二种在效果上是完全一样的，用insert函数插入数据，在数据的插入上涉及集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了。它可以覆盖以前关键字对应的值。
```c++
mapStudent.insert(map<int,string>::value_type(1,"student_one"));
mapStudent.insert(map<int,string>::value_type(1,"student_one"));
```
上面这两条语句执行后，map中1这个关键字的值是student_one，第二条语句并没有生效，那么这就涉及如何知道insert语句时否插入成功的问题了，可以用pair来获得是否插入成功，程序如下：  
```c++
pair<map<int,string>::iterator,bool>insert_pair;
insert_pair=mapStudent.insert(map<int,string>::value_type(1,"student_one"));
```
可以通过pair的第二个变量来知道 是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话，insert_Pair.second应该是true的，否则为false。  

##### 用pair判断insert到map的数据是否插入成功
```c++
#include <map>
#include <string>
#include <iostream>
using namespace std;
int main(){
    map<int, string> mapStudent;
    pair<map<int, string>::iterator, bool> insert_pair;
     insert_pair = mapStudent.insert(pair<int,string>(1,"student_one"));
    if(insert_pair.second == true){
        cout<<"Insert Successfully"<<endl;
    }
    else{
        cout<<"Insert Failure"<<endl;
    }
    insert_pair = mapStudent.insert(pair<int, string>(1, "student_two"));
    if(insert_pair.second == true){
          cout<<"Insert Successfully"<<endl;
     }else{
          cout<<"Insert Failure"<<endl;
    }
     map<int, string>::iterator iter;
     for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++){
          cout<<iter->first<<" "<<iter->second<<endl;
     }
     return 0;
}

```
程序的执行结果为：  
Insert Successfully  
Insert Failure  
1 student_one  
用pair判断insert到map的数据是否插入成功。pair变量insert_pair中的第一个元素的类型是map<int,string>::iterator，是和即将要判断的map中的Key、value类型一致的一个map迭代器。如果insert成功了，则insert_pair.second的结果为true，否则则为false。同一个key已经有数据之后，再insert就会失败。而数组插入的方式，则是直接覆盖。


##### 数据方式插入map覆盖原有的数据
```c++
#include <map>
#include <string>
#include <iostream>
using namespace std;
int main()
{
    map<int,string> mapStudent;
    mapStudent[1] =  "student_one"; 
    mapStudent[1] =  "student_two"; 
    mapStudent[2] =  "student_three";
    map<int, string>::iterator iter;
    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++){
        cout<<iter->first<<" "<<iter->second<<endl;
    }
    return 0;
}
```
程序的执行结果是：  
1 student_one  
2 student_two  
上面展示了mapStudent[1]上已经有数据"student_one"了，再用语句：  
```c+++
mapStudent[1]="student_two";
```
就可以直接覆盖成功。  

### map的遍历
map 数据的遍历，这里也提供3种方法，来对 map 进行遍历：应用前向迭代器方式、应用反向迭代器方式和数组方式 应用前向迭代器，上面举例程序已经讲解过了，这里着重讲解应用反向迭代器的方式，下面举例说明  
map方向迭代器的使用举例：  
```c++
#include <map>
#include <string>
#include <iostream>
using namespace std;
int main(){
    map<int,string> mapStudent;
    mapStudent[1] =  "student_one"; 
    mapStudent[2] =  "student_two"; 
    mapStudent[3] =  "student_three";
     map<int, string>::reverse_iterator   iter;
     for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++){
          cout<<iter->first<<" "<<iter->second<<endl;
     }
     return 0;
}
```
程序的执行结果是：  
3 student_three  
2 student_two  
1 student_one  
iter就是一个方向迭代器reverse_iterator，它需要使用rbegin()和rend()方法指出反向遍历的起始位置和终止位置。注意，前后遍历的一般是是从 begin()到end()遍历，而反向遍历是从rbegin()到rend()。  

用数组方式遍历map
```c++
#include<map>
#include<string>
#include<iostream>
using namespace std;
int main(){
    map<int,string> mapStudent;
    mapStudent[1] =  "student_one"; 
    mapStudent[2] =  "student_two"; 
    mapStudent[3] =  "student_three";
    int iSize = mapStudent.size();
    for(int i = 1; i <= iSize; i++){ 
        cout<<i<<" "<<mapStudent[i]<<endl; 
    } 
     return 0;
}
```
用 size（）方法确定当前 map 中有多少元素 用数组访问 vector 时，下标是从0-（ size-1），而用数组访问 map ，却是从 size ，这是有所不同的，请使用者多加注意

### map的查找
在这里可以充分体会到map在数据插入时保证有序的好处。要判定一个数据（关键字）是否在map中出现的方法比较多，这里给出2中常用的数据查找的方法。  

第一种：用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置，由于map的一对一的映射特性，就决定了count函数的返回值只有两个，要么是0，要么是1，当要判定的关键字出现时返回1.

第二种：用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器；如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。

用find方法查找map数据
```c++
#include<map>
#include<string>
#include<iostream>
using namespace std;
int main(){
    map<int,string> mapStudent;
    mapStudent[1] = "student_one"; 
    mapStudent[2] = "student_two"; 
    mapStudent[3] = "student_three";
     map<int, string>::iterator iter=mapStudent.find(1); 
     if(iter != mapStudent.end()){
          cout<<"Found, the value is "<<iter->second<<endl;
     }else{
          cout<<"Do not found"<<endl; 
    }
     return 0;
}
```
程序的的执行结果是：  
Find，the value is student_one

find函数返回的是一个迭代器，找不到对应数据的时候，则会返回mapStudent.end()

##### map的删除
用erase方法可删除map中的元素。erase的函数原型是：
```c++
map.erase(k);
```
删除map中键为k的元素，并返回size_type类型的值以表示删除的元素个数，代码如下：
```c++
map.erase(p);
```
从map中删除迭代器p所指向的元素。o必须指向map中确实存在的元素，而且不能等于map.end()，返回void类型，代码如下：  
```c++
map.erase(b,e);
```
从map中删除一段范围内的元素，该范围由迭代器对b和e标记。b和e必须标记map中的一段有效范围：即b和e都必须指向map中的元素或最后一个元素的下一个位置。而且，b和e要么相等（此时删除的范围为空），要么b所指向的元素必须出现在e所指向的元素之前，返回void类型，常用的是第二种，并且是在遍历的过程中删除元素。

用erase方法删除map中的元素
```c++
#include <map>
#include <string>
#include <iostream>
using namespace std;
int main(){
    map<int, string> mapStudent;
	mapStudent[1]="student_one";
	mapStudent[2]="student_two";
	mapStudent[3]="student_three";
	mapStudent[4]="student_four";	
    map<int, string>::iterator iter=mapStudent.begin();
    for(;iter!=mapStudent.end();){
	    if((*iter).second=="student_one"){
	        mapStudent.erase(iter++);
	    }
	    else{
	        ++iter;
	    }
	}	
    for(iter=mapStudent.begin();iter!=mapStudent.end();iter++){
	    cout<<iter->first<<" "<<iter->second<<endl;
	}
	return 0;
}
```
程序的执行结果是：  
2 student_two  
3 student_three  
4 student_four

注意：mapStudent.erase(iter++);中的iter++，不是erase(iter)，然后iter++。因为iter指针被erase之后就失效了，不能再用iter++，也不是erase(++iter)，这样就不是删除iter原来指向的元素了。

#### map的排序
map的排序默认按照Key从小到大排序，但有以下几点需要注意：（1）按照Key从大到小排序（2）Key（第一个元素）是一个结构体（3）想按value（第二个元素）排序

map是STL里面一个模板类，现在来看下map的定义：  
```c++
template<class Key,class T,class Compare=less<Key>,class Allocator=allocator<pair<const Key,T>>>class map;
```
它有4个参数，其中比较熟悉的有两个：Key和Value。第4个是Allocator,用来定义存储分配模型的。  

# set
set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一的，而且系统都能根据元素的值自动排序。应该注意的是set中数据元素的值不能直接被改变。C++STL中标准关联容器set、multiset、map、multimap内部采用的都是红黑树。红黑树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。

# set基础
（1）为何map和set的插入删除效率比用其他序列容器高？  
表面上看，因为对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。

因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点即可，这里的一切操作就是指针换来换去，和内存移动没有关系。

（2）为何每次insert之后，以前保存的iterator不会失效？  
iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢？（当然被删除的那个元素本身已经失效了）。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放 ，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使用push_back的时候，容器的内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，并申请新的更大的内存，并复制已有的数据到新的内存，最后把需要插入的元素放到最后来解决，那么以前的内存指针自然就不可用了。特别是在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator

（3）当数据元素过多时，set的插入和搜索速度变化如何？  
如果知道log2的关系就应该彻底了解这个答案。在set中查找时使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个员，虽多比较5次。那么有10000个元素时为log10000,即最多为14次，如果是20000个元素呢？最多不过15次。可见，当数据量增大一倍的时候，搜索次数只不过多了1次了。

#### set的查增删
```c++
#include <iostream>
#include <string>
#include <set>
#include <string.h>
#include <iterator>
using namespace std;
struct strLess{
   bool operator() (const char *s1, const char *s2) const {
    return strcmp(s1, s2) < 0;
   }
};
void printSet(set<int> s){
	copy(s.begin(), s.end(), ostream_iterator<int>(cout, ", ") );
	/*
	set<int>::iterator iter;
	for (iter = s.begin(); iter != s.end(); iter++)
	    cout<<"set["<<iter-s.begin()<<"]="<<*iter<<", "; //Error
	cout<<*iter<<", ";
	*/
	cout<<endl;
}

int main(){
	/*创建set对象，共5种方式，提示如果比较函数对象及内存分配器未出现，即表示采用的是系统默认方式*/
	/*创建空的set对象，元素类型为int，*/
	set<int> s1;
	/*创建空的set对象，元素类型char*，比较函数对象(即排序准则)为自定义strLess*/
	set<const char*, strLess> s2( strLess); 
	/*利用set对象s1,拷贝生成set对象s2*/
	set<int> s3(s1); 
	/*用迭代区间[&first, &last)所指的元素，创建一个set对象*/
	int iArray[] = {13, 32, 19};
	set<int> s4(iArray, iArray + 3);
	/*用迭代区间[&first, &last)所指的元素，及比较函数对象strLess，创建一个set对象*/
	const char* szArray[] = {"hello", "dog", "bird" };
	set<const char*, strLess> s5(szArray, szArray + 3, strLess() );
	/*元素插入：
	1,插入value，返回pair配对对象，可以根据.second判断是否插入成功。(提示:value不能与set容器内元素重复)
    pair<iterator, bool> insert(value)
    2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功
    iterator insert(&pos, value)
    3,将迭代区间[&first, &last)内所有的元素，插入到set容器
	void insert[&first, &last);
	*/
	cout<<"s1.insert() : "<<endl;
	for (int i = 0; i <5 ; i++)
        s1.insert(i*10);
    printSet(s1);
	
	cout<<"s1.insert(20).second = "<<endl;
	if (s1.insert(20).second)
        cout<<"Insert OK!"<<endl;
	else
        cout<<"Insert Failed!"<<endl;
	cout<<"s1.insert(50).second = "<<endl;
	if (s1.insert(50).second){
		cout<<"Insert OK!"<<endl;
		printSet(s1);
	}else
		cout<<"Insert Failed!"<<endl;
	cout<<"pair<set<int>::iterator, bool> p;\np = s1.insert(60);\nif (p.second):"<<endl;
	pair<set<int>::iterator, bool> p;
	p = s1.insert(60);
	if (p.second){
		cout<<"Insert OK!"<<endl; 
		printSet(s1);
	}
	else
		cout<<"Insert Failed!"<<endl;

   /*元素删除
    1,size_type erase(value) 移除set容器内元素值为value的所有元素，返回移除的元素个数
    2,void erase(&pos) 移除pos位置上的元素，无返回值
    3,void erase(&first, &last) 移除迭代区间[&first, &last)内的元素，无返回值
    4,void clear()， 移除set容器内所有元素*/
	cout<<"\ns1.erase(70) = "<<endl;
	s1.erase(70);
	printSet(s1);
	cout<<"s1.erase(60) = "<<endl;
	s1.erase(60);
	printSet(s1);

    cout<<"set<int>::iterator iter = s1.begin();\ns1.erase(iter) = "<<endl;
    set<int>::iterator iter = s1.begin();
    s1.erase(iter);
    printSet(s1);

    /*元素查找
	count(value)返回set对象内元素值为value的元素个数
	iterator find(value)返回value所在位置，找不到value将返回end()
	lower_bound(value),upper_bound(value), equal_range(value)*/
	cout<<"\ns1.count(10) = "<<s1.count(10)<<", s1.count(80) = "<<s1.count(80)<<endl;
	cout<<"s1.find(10) : ";
	if (s1.find(10) != s1.end()) 
		cout<<"OK!"<<endl;
	else
		cout<<"not found!"<<endl;
	
	cout<<"s1.find(80) : ";
	if (s1.find(80) != s1.end()) 
		cout<<"OK!"<<endl;
	else
		cout<<"not found!"<<endl;
	/*其它常用函数*/
	cout<<"\ns1.empty()="<<s1.empty()<<", s1.size()="<<s1.size()<<endl;
	set<int> s9;
	s9.insert(100);
	cout<<"s1.swap(s9) :"<<endl;
	s1.swap(s9);
	cout<<"s1: "<<endl;
	printSet(s1);
	cout<<"s9: "<<endl;
	printSet(s9);
	return 0;
}
```
(1)set对象的创建方式有5种，如下所述：  
1)创建空的set对象，元素类型为int：  
```c++
set<int>s1;
```
2)创建空的set对象，元素类型char* ，比较函数对象（即排序准则）为自定义strLess:  
```c++
set<const char*,strLess>s2(strLess);
```
3)利用set对象s1，拷贝生成set对象s2  
```c++
set<int>s3(s1);
```
4)用迭代区间[&first,&last]所指的元素，创建一个set对象：  
```c++
int iArray[]={13,32,19};
set<int>s4(iArray,iArray+3);
```
5)用迭代区间[&first,&last]所指的元素，及比较函数对象strLess,创建一个set对象：  
```c++
const char* szArray[]={"hello","dog","bird"};
set<const char*,strLess>s5(szArray,szArray+3,strLess());
```
(2)元素插入的3种方式，如下所述：  
1）插入value，返回pair配对的对象，可以根据.second判断是否插入成功。（注意：value不能与set容器内元素重复）  
2）在pos位置之前插入value，返回新元素位置，但不一定能插入成功。  
3）将迭代器区间[&first,&last]内所有的元素，插入到set容器。

（3）元素删除的4种方式，如下所述。  
1）size_type erase(value)移除set容器内元素值为value的所有元素，返回移除的元素个数。   
2）void erase(&pos)移除pos位置上的元素，无返回值。  
3）void erase(&first,&last)移除迭代器区间[&first,&last]内的元素，无返回值。  
4）void clear(),移除set容器内所有元素。

（4）元素查找的2种方式，如下所述：  
1）count(value)返回set对象内元素值为value的元素个数。  
2）iterator find(value)返回value所在位置，找不到value将返回end()。

（5）其他set中的常用方法。  
begin（），返回 set 容器的第一个元素  
end（），返回 set 容器的最后一个元素  
clear（） 删除 set 容器中的所有的元素  
empty（），判断 set 容器是否为空  
max_size（），返回 set 容器可能包含的元素最大个数  
size（），返回当前 set 容器中的元素个数  
rbegin（），返回的值和 end （）相同  
rend（），返回的值和 rbegin （）相同  

# STL里的内存池实现
STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池  
二级分配器设计的非常巧妙，分别给8k，16k,...128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存的时候从合适大小的链表中取一块下来。假设需要分配一块10k的内存，那么就找到最小的大于等于10的块，也就是16k，从16k的空闲链表里取出一个用于分配，释放该块内存时，将内存节点归还给链表  
如果要分匹配的内存大于128k则直接调用一级分配器  
为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示节点的地址

# STL里set和map是基于什么实现的，红黑树的特点
1.set和map是基于红黑树实现的。  
2.红黑树是一种平衡二叉查找树，与AVL树的区别是什么？AVL树是完全平衡树，红黑树基本上平衡的。  
3.为什么选择用红黑树而不用AVL树呢？因为红黑树是平衡树，其插入和删除的效率都是O(logN)，与AVL相比红黑树插入和删除最多只需要3次旋转，而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多了。  
红黑树的定义：  
（1）节点是红色或者黑色
（2）根结点一定是黑色
（3）相连两个结点不能同一种颜色
（4）叶子结点一定是黑色
（5）从根结点到每一个叶子结点的路径上的黑结点数目相同

# string类的实现
String的原型代码如下：  
```c++
class String
{
public:
	String(const char *str = NULL);//普通构造函数
	String(const String &other);//拷贝构造函数
	~String();//析构函数
	String& operator=(const String &other);//赋值函数
	String& operator+(const String &other);//字符串连接
	bool operator==(const String &other);//判断相等
	int getLength();//返回长度
private:
	char *m_data;//私有变量保存字符串
};
```
从上述程序可以看到，string类其实是一个对字符串指针有一系列操作动作的的类，也就是说，string类的底层是一个字符串指针。
# 普通构造函数

```c++
String::String(const char* str)
{
	if (str == NULL) 
	{
		m_data = new char[1];
		*m_data = '\0';
		//对空字符串自动申请存放结束标识'\0'的加分点，对m_data加NULL判断
	}
	else
	{
		int length = strlen(str);
		m_data = new char[length + 1];
		strcpy(m_data, str);
	}
}
```
普通构造函数里需要注意的是，传入的是个char* 类型的字符串。如果传入的str是个空的字符串，那这个string就也是一个空的字符串，直接用\0赋值。如果传入的str是非空字符串，私有变量m_data就需要预留length+1的长度，其中“+1”是用来放最后的'\0'的，因为strlen计算字符串长度时，没把'\0'算进去

# String的析构函数

```c++
String::~String()
{
	if (m_data)
	{
		delete[] m_data;//或delete m_data
		m_data = 0;
	}
}
```
析构函数的主要功能是删除成员变量，需要先判断字符串指针是否为空，如果不为空，再将其删除，并将其指向NULL


# 拷贝构造函数

```c++
String::String(const String& other)//输入参数为const
{
	if (!other.m_data)//对m_data加NULL判断
	{
		m_data = 0;
	}
	m_data = new char[strlen(other.m_data) + 1];
	strcpy(m_data, other.m_data);
}
```
拷贝构造函数里需要注意的是，传入的参数是个常引用，这样可以不用新增一个栈变量和参数内容可以保持不变，不被修改


# 赋值函数

```c++
String& String::operator=(const String &other)
{
	//输入参数为const型
	if (this != &other)//检查是否自赋值
	{
		delete[] m_data;//释放原有的内存资源
		if (!other.m_data)//对m_data作NULL判断
		{
			m_data = 0;
		}
		else
		{
			m_data = new char[strlen(other.m_data) + 1];
			strcpy(m_data, other.m_data);
		}
	}
	return *this;//返回本对象的引用
}
```
赋值函数里需要注意的是，如果传入的参数内容已与本身的内容一致，则不需要赋值。如果传入的参数内容与本身内容不一致，需要先清空本身的内容。

# 字符串连接

```c++
String& String::operator+(const String &other)
{
	String newString;
	if (!other.m_data)
	{
		newString = *this;
	}
	else if (!m_data)
	{
		newString = other;
	}
	else
	{
		newString.m_data = new char[strlen(m_data) + strlen(other.m_data) + 1];
		strcpy(newString.m_data, m_data);
		strcpy(newString.m_data, other.m_data);
	}
	return newString;
}
```
字符串连接函数里需要注意的分3种情况：传入的参数内容为空、本身内容为空或两者内容都不为空。

# 判断相等

```
bool String::operator==(const String &other)
{
	if (strlen(m_data) != strlen(other.m_data))
	{
		return false;
	}
	else
	{
		return strcmp(m_data, other.m_data) ? false : true;
	}
}
```
判断相等函数，返回值只有false和true，先判断长度是否一致，再判断内容是否一致

# 返回长度

```
int String::getLength()
{
	return strlen(m_data);
}
```
返回长度函数，只需要strlen直接计算char* 的长度即可。

# c四种类型转换

# static_cast

static_cast用的最多，对于各种隐式转换，非const转const，void* 转指针等，static_cast能用于多态上转化，如果向下转能成功但是不安全，结果未知。

# dynamic_cast

dynamic_cast用于动态类型转化，只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转化的原理

# const_cast

const_cast用于将const变量转化为非const

# reinterpret_cast

reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出现问题，尽量少用


# 重载和重写（覆盖）的区别
从定义上来说：

重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

* [死锁](#死锁)
* [内存池](#内存池)
* [进程调度](#进程调度)
* [孤儿进程和僵死进程](#孤儿进程和僵死进程)
* [分页式内存管理](#分页式内存管理)
* [分段式内存管理](#分段式内存管理)
* [段页式内存管理](#段页式内存管理)
* [什么是虚拟内存](#什么是虚拟内存)
* [页面置换算法](#页面置换算法)
* [颠簸](#颠簸)
* [虚拟内存的作用](#虚拟内存的作用)
* [虚拟内存的实现](#虚拟内存的实现)
* [Linux如何避免内存碎片化](#linux如何避免内存碎片化)
* [内部碎片和外部碎片](#内部碎片和外部碎片)
# 死锁
### 什么是死锁
死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。例如，在某一个计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印设备的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程互相无休无止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。

### 死锁产生的原因
1.系统资源的竞争  
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。  
2.进程运行推进顺序不适当  
进程在运行过程中，请求和释放资源的顺序不当，会导致死锁

### 死锁产生的条件
1.互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。  

2.请求与保持条件：进程已经保持了至少一各资源，但又提出了新的资源的请求，而该资源已被其他进程所占有，此时请求进程被阻塞，但对自己已获得的资源保持不。  
3.不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是自己释放）

4.循环等待条件：若干进程间形成首尾相接循环等待资源的关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

### 处理死锁的方法
1.预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防死锁的发生。

2.避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。

3.检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除

4.解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来

#### 预防死锁
1.破坏“互斥”条件  
就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。  
注意：互斥条件不能被破坏，否则会造成结果的不可再现性

2.破坏“占有并等待”条件  
破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。  
方法一：创建进程时，要求它申请所需的全部资源、系统或满足其所要求，或什么都不给它。这是所谓的“一次性分配”方案。  
方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对资源S的申请，即使它可能很快又要用到资源R。

3.破坏“不可抢占”条件  
破坏“不可抢占”条件是允许对资源实行抢夺  
方法一：如果占有某些资源的一个进程进行进一步资源申请被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。  
方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只要在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。  

4.破坏“循环等待”条件  
破坏“循环等待”条件的一种方法，是将系统的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。

#### 避免死锁
预防死锁和避免死锁的区别：  
预防死锁是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现，而避免死锁则不那么严格的限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。

1.有序资源分配法  
这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1，磁带机为2，磁盘为3等）申请时必须以上升的次序。系统要求申请进程：  
（1）对它所必须使用的而且属于同一类的所有资源，必须一次申请完。  
（2）在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2.进程PB，使用资源的顺序是R2,R1若采用动态分配有可能形成环路条件，造成死锁。  
采用有序资源分配法：R1的编号为1，R2的编号为2；  
PA：申请次序是:R1,R2  
PB：申请次序是：R1,R2  
这样就破坏了环路条件，避免了死锁的发生

2.银行家算法  
当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。  
四个条件：  
1.分批向银行贷款时，申请的总额不能超过一开始申请的额度。  
2.申请贷款时不能超过银行现有资金的数目。  
3.当银行资金不能满足顾客贷款需求时，可以推迟支付，但是肯定会让顾客在需求时间内得到贷款。  
4.顾客拿到贷款后必须在规定时间内归还

3.系统安全状态法  
即在分配资源之前，就应该检测此次资源分配的安全性，如果此次分配资源会导致进程进入不安全状态，那就等待，如果不会，则分配资源

# 内存池
　　内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不是将内存返回给操作系统，而是返回内存池，当程序退出（或者特点时间）时，内存池才将之前申请的内存真正释放。

# 进程调度

# 孤儿进程和僵死进程
1.孤儿进程是怎么产生的？  
一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

2.僵死进程是怎么产生的？
一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。

3.僵死进程的危害？

4.如何避免僵死进程的产生？


# 什么是虚拟内存
　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块（称为帧，通常页和帧大小相等）还有一些没有加载的内存中的对应在硬盘上。
  
　　请求分页系统、请求分段系统、请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。 
  
   <div align="center"> <img src="./虚拟内存.jpg" width="600"/> </div><br>
   
　　由上图可以看出，虚拟内存实际上可以比物理内存大，当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如0，1，2）如果虚拟内存的页并不存在于物理内存中（如 3，4）会产生缺页中断，从磁盘中取得缺得的页存入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

# 页面置换算法

1.FIFO先进先出算法：在操作系统中经常被用到，比如作业调度  
2.LRU（least recently use）最近最少使用算法：根据使用时间到现在的长短来判断  
3.LFU(least frequently use)最少使用次数算法：根据使用次数来判断  
4.OPT(Optimal replacement)最优置换算法：理论最优，就是要保证置换出去的是不再被使用的页，或者是实际内存中最晚使用的算法


# 颠簸
颠簸本质是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的也都在使用，它置换一个页，但立刻再次需要这个页。因此，会不断出现缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）  
内存颠簸的解决策略包括：  
1.如果是因为页面替换策略失误，可以修改替换算法来解决这个问题。  
2.如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。  
3.否则，还剩下两个办法，终止该进程和增加物理内存容量
# 虚拟内存的作用


# 虚拟内存的实现

# Linux如何避免内存碎片化
1.伙伴算法，用于管理物理内存，避免内存碎片
2.高速缓存Slab层用于管理内核分配内存，避免碎片。


# 内部碎片和外部碎片
在内存管理中，内部碎片是已经被分配出去的内存空间大于请求所需的内存空间。  
外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲快。  
固定分区存在内存碎片，可变式分区分配会存在外部碎片  
页式虚拟存储系统存在内部碎片，段式虚拟存储系统存在外部碎片。  
为了有效的利用内存，使内存产生更少的 碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片  
为了共享要分段，在段的换入换出时形成外部碎片，比如5k的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。

* [IO多路复用](#io多路复用)
  * [1.select系统调用](#1-select系统调用)
  * [2.poll系统调用](#2-poll系统调用)
  * [3.epoll系统调用](#3-epoll系统调用)  

* [1.I/O复用函数的比较](#1-i/o复用函数的比较)
# IO多路复用
　　I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。通常网络程序在下列情况下需要使用I/O复用技术：  
1.客户端程序要同时处理多个socket。  

2.客户端程序要同时处理用户输入和网络连接。  

3.TCP服务器要同时处理监听socket和连接socket。这是I/O复用使用最多的场合。  

4.服务器要同时处理TCP请求和UDP请求。  

5.服务器要同时监听多个端口，或者处理多种服务。  

　　只要指出的是，I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。
  
　　Linux下实现I/O复用的系统调用主要有select、poll和epoll。
  
  # 1. select系统调用
  select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。
  
  
  
  
  
  
  # 2. poll系统调用
  poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。
  
  
  
  
  
  # 3. epoll系统调用
  epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无序像select和poll那样每次调用都需重复传入文件描述符集和事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用如下epoll_create函数来创建：
  ```c++
  #include<sys/epoll.h>
  int epoll_create(int size)
  ```
  
  
  # 4. I/O复用函数的比较
   系统调用|select|poll|epoll
  ---|:--:|:--:|---:
  事件集合|用户通过3个参数分别传入感兴趣的可读、可写及异<br>常等事件，内核通过对这些参数的在线修改来反馈其中<br>的就绪事件。这使得用户每次调用select都要重置这3<br>个参数|统一处理所有事件类型，因此只需要一个事件集参数。<br>用户通过poll.events传入感兴趣的事件，内核通过<br>修改pollfd.revents反馈其中就绪的事件|内核通过一个事件表直接管理用户感兴趣的所有<br>事件。因此每次调用epoll_wait时，无须反复传入用户感兴趣的事件。epoll_wait<br>系统调用的参数events仅用来反馈就绪的事件。
应用程序索引就绪文件<br>描述符的时间复杂度|O(n)|O(n)|O（1）
最大支持文件描述符数|一般有最大值限制|65535|65535
工作模式|LT|LT|支持ET高效模式
内核实现和工作效率|采用轮询方式来检测就绪事件，算法时间复杂度为O(n)|采用轮询方式来检测就绪事件，算法时间复杂度为O(n)|采用回调方式来检测就绪事件，算法时间复杂度为O(1)

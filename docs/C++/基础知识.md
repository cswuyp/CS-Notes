* [面向对象的三个基本特征](#面向对象的三个基本特征)
* [虚函数的实现原理](#虚函数的实现原理)
* [怎么用C语言实现虚函数的功能](#怎么用c语言实现虚函数的功能)
* [在C++中的虚函数表是什么时期建立的](#在c中的虚函数表是什么时期建立的)
* [在C++对象内存布局](#在c对象内存布局)
* [在C++自定义的函数一定要先声明或者定义在main函数前面吗？](#在c自定义的函数一定要先声明或者定义在main函数前面吗)
* [sort函数的实现原理](#sort函数的实现原理)
* [malloc函数的实现原理](#malloc函数的实现原理)
* [new实现原理](#new实现原理)
* [new和malloc的区别](#new和malloc的区别)
* [free实现原理](#free实现原理)
* [delete实现原理](#delete实现原理)
* [realloc扩容的原理](#realloc扩容的原理)
* [拷贝构造函数](#拷贝构造函数)
* [构造函数可否为虚函数](#构造函数可否为虚函数)
* [父类的析构函数为什么要声明为虚函数](#父类的析构函数为什么要声明为虚函数)
* [描述内存分配方式以及它们的区别](#描述内存分配方式以及它们的区别)
* [#const与#define相比，有何优点](#const与define相比有何优点)
* [数组与指针的区别](#数组与指针的区别)
* [引用与指针有什么区别](#引用与指针有什么区别)
* [野指针](#野指针)
* [初始化列表初始化](#初始化列表初始化)
* [必须在构造函数初始化列表中进行初始化的数据成员有哪些](#必须在构造函数初始化列表中进行初始化的数据成员有哪些)
* [构造函数初始化](#构造函数初始化)
* [const的作用](#const的作用)
* [const成员函数的使用](#const成员函数的使用)
* [动态创建数组](#动态创建数组)
* [内联函数有什么优点,内联函数与宏定义的区别](#内联函数有什么优点内联函数与宏定义的区别)
* [static关键字作用](#static关键字作用)
* [static成员函数的使用](#static成员函数的使用)
* [右值引用](#右值引用)
* [移动构造函数](#移动构造函数)
* [重载和重写（覆盖）的区别](#重载和重写覆盖的区别)



* [STL容器的使用](#STL容器的使用)
  * [vector](#vector)
    * [vector基础](#vector基础)
  * [map](#map)
    * [map基础](#map基础)
  * [set](#set)
    * [set基础](#set基础)
* [STL里的内存池实现](#stl里的内存池实现)
* [STL里set和map是基于什么实现的，红黑树的特点](#stl里set和map是基于什么实现的红黑树的特点)

* [string类的实现](#string类的实现)
  * [普通构造函数](#普通构造函数)
  * [String的析构函数](#string的析构函数)
  * [拷贝构造函数](#拷贝构造函数)
  * [赋值函数](#赋值函数)
  * [字符串连接](#字符串连接)
  * [判断相等](#判断相等)
  * [返回长度](#返回长度)
  
  
  
* [智能指针](#智能指针)
  * [auto_ptr](#auto_ptr)
  * [unique_ptr](#unique_ptr)
  * [weak_ptr](#weak_ptr)
  * [share_ptr](#share_ptr)

* [C++四种类型转换](#c四种类型转换)
  * [static_cast](#static_cast)
  * [dynamic_cast](#dynamic_cast)
  * [const_cast](#const_cast)
  * [reinterpret_cast](#reinterpret_cast)

# 面向对象的三个基本特征
1.封装  
简单来讲：将现实世界的事物抽象成计算机领域中的对象，对象同时具有属性和行为，这种抽象就是封装。  
封装的一个重要特性：数据隐藏，对象只对外提供与其它对象交互的必要接口，而将自身的某些属性和实现细节对外隐藏，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或者错误的使用了对象的私有部分，这样就在确保正常交互的前提下，保证了安全性。  
2.继承  
面向对象的一个重要特性是复用性，继承是实现复用性的一个重要手段，可以在不重复编写以实现的功能的前提下，对功能进行复用和拓展。  
继承概念的实现方式有两类：实现继承与接口继承  
实现继承是指直接使用基类的属性和方法而无需额外编码的能力。  
接口继承是指仅使用属性和方法的名称，但是子类必须提供实现的能力。  
3.多态  
当存在继承关系时，允许将父类对象看成和它的一个或多个子类对象等同，这样可以根据当前赋给父类对象的子类对象的具体特性以不同的方式进行运行，  
多态的几个前提  
a.要有继承关系  
b.要有方法重写  
c.要有父类引用指向子类对象  
多态的好处  
a.提高了代码的维护性（继承保证）  
b.提高了代码的扩展性（由多态保证）  
多态的限制  
不能使用子类的特有属性和行为 

多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。
动态多态实现有几个条件：  
(1) 虚函数；  
(2) 一个基类的指针或引用指向派生类的对象；  
基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。  
每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。  
虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。      
编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。  

# 虚函数的实现原理

我们可以从虚函数表和虚函数指针来了解虚函数的实现原理。  
简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。
含有虚函数的类会
http://www.cnblogs.com/malecrab/p/5572730.html

# 怎么用C语言实现虚函数的功能
参照前面C++虚函数的实现原理，可以自己添加虚函数指针和虚函数表来实现虚函数功能。  

# 在C++中的虚函数表是什么时期建立的
虚函数表是编译期确定的，虚函数表中存放的是虚函数的地址，而虚函数的地址是在编译期间就确定的所以虚函数表应该也是在编译期就确定的。 
我们在《深度探索C++对象模型》的4.2节能够找到完美的答案，具体摘抄如下：  
“表格中的virtual functions地址是如何构建起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或者替换之。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完美掌控，不需要执行期的任何介入。”

# 在C++对象内存布局
https://www.cnblogs.com/wuyepeng/p/9863296.html

# 在C++自定义的函数一定要先声明或者定义在main函数前面吗？
不一定，C++中的执行总是从main函数开始的（无论main放在什么位置），如果自定义的函数放于main函数之后则需要在main函数前声明该自定义函数，如果自定义的函数放于main函数前则不需要额外的声明，否则在main函数中调用该自定义函数时会出现无法识别。


# sort函数的实现原理
　　STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。
  
# malloc函数的实现原理
https://blog.csdn.net/hudazhe/article/details/79535220

# new实现原理
　　当我们使用关键字new在堆上动态创建一个对象时，它实际上做了三件事：（1）获得一块内存空间，（2）调用构造函数，（3）返回正确的指针。
  https://blog.csdn.net/xxpresent/article/details/53024555
  
# new和malloc的区别
1.new分配内存按照数据类型进行分配，malloc分配内存按照内存大小进行分配。  
2.new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。但是还需要注意的是，之前看过一个题说int p=new int与int p=new int()的区别，因为int属于C++内置对象，不会默认初始化，必须显示调用构造函数，但是对于自定义对象都会默认调用构造函数初始化。翻阅资源后，在C++11中两者没有区别了，自己测试的结构也都是为0；  
3.new返回的是指定对象的指针，而malloc返回的是void* 因此，malloc的返回值一般都需要进行类型转化。  
4.new是一个操作符可以重载，malloc是一个库函数。  
5.new分配的内存要用delete销毁，malloc要用free来销毁，delete销毁的时候会调用对象的析构函数，而free则不会。  
6.malloc分配的内存不够的时候，可以用realloc扩容，new没有这样的操作。  
7.new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try...catch语法，而malloc则应该判断指针的返回值。为了兼容很多C程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL  
8.new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int)* n  
9如果不够可以继续谈new和malloc的实现，空闲链表，分配方法（首次适配原则，最佳适配原则，最差适配原则，快速适配原则）delete和free的实现原理。

# free实现原理

# delete实现原理


# realloc扩容的原理


# 拷贝构造函数
### 什么时候需要自己定义拷贝构造函数，以避免浅拷贝问题？  
一般情况下，当类中成员有指针变量，类中有动态内存分配时常常需要用户自己定义拷贝构造函数。  
### 在什么情况下系统会调用拷贝构造函数（三种情况）  
（1）用类的一个对象去初始化另一个对象  
（2）当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用  
（3）当函数的返回值是类的对象或引用时

# 构造函数可否为虚函数


# 父类的析构函数为什么要声明为虚函数
1：每个析构函数只会清理自己的成员（成员函数前没有virtual）。

2.为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，当对象销毁时会自动调用基类的析构函数，如果此时基类的析构函数为虚函数才会再调用基类指针指向的派生类的析构函数，否则不会调用派生类的析构函数造成内存泄露。

# 描述内存分配方式以及它们的区别

# #const与#define相比，有何优点

# 数组与指针的区别
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

(1)修改内容上的差别
```
char a[] = “hello”;

a[0] = ‘X’;

char *p = “world”; // 注意p 指向常量字符串

p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
```
(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
```
char a[] = "hello world";

char *p = a;

cout<< sizeof(a) << endl; // 12 字节

cout<< sizeof(p) << endl; // 4 字节

计算数组和指针的内存容量

void Func(char a[100])

{

cout<< sizeof(a) << endl; // 4 字节而不是100 字节

}
```
# 引用与指针有什么区别
1.指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问。  
2.指针可以改变地址，从而改变所指的对象，而引用一经初始化就不可更改  
3.引用在定义时必须初始化，而指针则不需要。  
4.指针有指向常量的指针和指针常量，而引用没有常量引用    
5.指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全很多但是比较死板。  


# 野指针

# 初始化列表初始化

# 必须在构造函数初始化列表中进行初始化的数据成员有哪些
（1）常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面  
（2）引用成员，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面  
（3）没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
# 构造函数初始化


# const的作用
1.const修饰全局变量  
2.const修饰局部变量  
3.const修饰指针，const int*  
4.const修饰指针指向的对象，int * const;    
5.const修饰引用该做形参  
6.const修饰成员变量，必须在构造函数列表中初始化  
7.const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变

# const成员函数的使用

# 动态创建数组


# 内联函数有什么优点,内联函数与宏定义的区别
1.宏定义在预编译的时候就会进行宏替换  
2.内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译（内联是给编译器的一个建议编译器可以不听）    
3.内联函数相对比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。  
4.使用宏定义函数要特别注意给所有单元都加上括号，否则很容易出错

# static关键字作用
1.static修饰局部变量。  
2.static修饰全局变量。  
3.static修饰普通函数。  
4.static修饰成员函数。  
5.static修饰成员变量。

# static成员函数的使用

# 右值引用

# 移动构造函数


# STL容器的使用
STL是一个标准模板库，是一个高效的C++程序库。

# vector
vector是线性容器，它的元素严格按照线性序列排序，和动态数组很相似。和数组类似的是，它的元素存储在一块连续的存储空间中，这也意味着不仅可以使用迭代器(iterator)访问元素，还可以使用指针的偏移方式访问。和常规数组不一样的是，vector能够自动存储元素，可以自动增长或缩小存储空间。  

vector的优点如下所述：  
（1）可以使用下标访问个别的元素。  
（2）迭代器可以按照不同的方式遍历容器。  
（3）可以在容器的末尾增加和删除元素。  
和数组相比，虽然容器在自动处理容量的大小时会消耗更多的内存，但是容器能提供和数组一样的性能，而且能更好地调整存储空间的大小。  

和其他标准的顺序容器相比，vector能更有效访问容器内的元素和在末尾添加和删除元素，而在其他位置添加和删除元素，vector则不及其他顺序容器，在迭代器和 引用也不比lists支持的好。

容器的大小和容器的容量是有区别的，大小是指元素的个数，容量是分配的内存大小，容量一般不小于容器的大小。vector::size()返回容器的大小，vector::capacity()返回容量值，容量多于容器大小的部分用于以防容器大小的增加使用。每次重新分配内存都会很影响程序的性能，所以一般分配的容量都大于容器的大小，若要自己指定分配的容量大小，则可以使用vector::reserve()，但是规定的值要大于size()值。

# vector基础
#### vector的查增删
##### vector的初始化和遍历
vector<T>v1|v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
---|:--:
vector<T>v2(v1)|v2中包含有v1所有元素的副本
vector<T>v2=v1|等价于v2(v1)，v2中包含有v1所有元素的副本
vector<T>v3(n,val)|v3包含了n个重复的元素，每个元素的值都是val
vector<T>v4(n)|v4包含了n个重复地执行了值初始化的对象
vector<T>v5{a,b,c...}|v5包含了初始值个数的元素，每个元素被 赋予相应的初始值
vector<T>v5={a,b,c...}|等价于v5{a,b,c...}

vector的遍历有for(int i=0;i<a.size();++i)、for(iter=vec.begin();iter!=vec.end();iter++)、for(auto it:vec)

##### vector中存放结构体时的排序

##### 结构体外定义比较函数


##### vector的查找
使用find函数在vector中进行查找
```c++
#include <iostream>
# include<algorithm>
#include<vector>
using namespace std;
int main()
{
	vector<int> vec{ 1,2,3,4,5 };
	vector<int>::iterator iter = find(vec.begin(), vec.end(), 3);
	if (iter == vec.end())
	{
		cout << "Not Find" << endl;
	}
	else
	{
		cout << "Found" << endl;
		return 0;
	}
}
```
##### vector的删除
vector中的删除，可以有erase或pop_back()。erase可以删除指定元素或指定位置的元素，而pop_back只能去掉数组的最后一个数据

erase的函数原型有以下两种形式：  
iterator erase(iterator position)  
iterator erase(iterator first,iterator last)  
假设有这样的程序:  
```c++
vector<int>vec{1,2,3,4,5};
for (vector<int>::iterator iter = vec.begin(); iter != vec.end(); iter++)
{
	if (*iter == 3)
	{
		vec.erase(iter);
	}
}
```
乍一看这段代码很正常，其实这里面隐藏着一个很严重的错误，当vec.erase()语句执行了之后，iter就变成一个野指针，对一个野指针进行++iter操作肯定是会出错的。  
查看MSDN，对于erase的返回值是这样描述的:An iterator that designates the first element remaining beyond any elements removed,or a pointer to the end of the vector if no such element exists,于是改代码：
```c++
for (vector<int>::iterator iter = vec.begin(); iter != vec.end(); iter++)
{
	if (*iter == 3)
	{
		iter=vec.erase(iter);
	}
}
```
这段代码也是错误的：（1）无法删除两个连续的3，（2）当数字3位于vector最后位置的时候，也会出错（在vec.end()上执行++操作）。正确的代码如下：  
使用erase删除vector中某个元素  
```c++
#include <iostream>
# include<algorithm>
#include<vector>
using namespace std;
int main()
{
	vector<int>vec{ 1,2,3,3,4,5 };
	vector<int>::iterator iter = vec.begin();
	for (; iter != vec.end();)
	{
		if (*iter == 3)
		{
			iter = vec.erase(iter);
		}
		else
		{
			++iter;
		}
	}
	for (iter = vec.begin(); iter != vec.end(); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;
	return 0;
}
```
for语句条件里面删除元素时，返回值指向已删除元素的下一个位置，不是删除元素时则直接进行++操作。  
使用vec.erase(vec.begin()+i,vec.end()+j)语句则是删除区间[i,j-1]间的元素。  
而pop_back只能去掉数组的最后一个元素。

##### vector的增加
vector中的增加，可以有insert和push_back。insert是插入元素到某个位置中，push_back是在最后添加一个元素。

insert的函数原型有以下3种形式：  
```c++
iterator insert(iterator loc,const TYPE &val);//在指定位置loc前插入值为val的元素，返回指向这个元素的迭代器  

void insert(iterator loc,size_type num,const TYPE &val);//在指定位置loc前插入num个值为val的元素  

void insert(iterator loc,input_iterator start,input_iterator end);//在指定位置loc前插入区间[start,end)的所有元素

```
vector的查增删用法举例
```c++
#include <iostream>
#include<algorithm>
#include<vector>
using namespace std;
void print(vector<int>v)
{
	vector<int>::iterator iter = v.begin();
	for (; iter != v.end(); iter++)
	{
		cout << *iter << " ";
	}
	cout << endl;
}
int main()
{
	vector<int>v;//现在容器中有0个元素
	int values[] = { 1,3,5,7 };
	v.insert(v.end(), values + 1, values + 3);//现在容器中有2个元素分别为：3，5
	print(v);
	v.push_back(9);//现在容器中有3个元素分别为3，5，9
	print(v);
	v.erase(v.begin() + 1);//现在容器中2个元素分别为3，9
	print(v);
	v.insert(v.begin() + 1, 4);//现在容器中有3个元素分别为3，4，9
	print(v);
	v.insert(v.end() - 1, 4, 6);//现在容器中有7个元素分别为3，4，6，6，6，6，9
	print(v);
	v.erase(v.begin() + 1, v.begin() + 3);//现在容器中有5个元素分别为3，6，6，6，9
	print(v);
	v.pop_back();//现在容器中有4个元素分别为3，6，6，6
	print(v);
	v.clear();//现在容器中有0个元素
	print(v);
	if (true == v.empty())//如果容器为空则输出null
	{
		cout << "null" << endl;
	}
	return 0;
}
```
注意  
v.insert(v.end(),values+1,values+3);  
就是将数组第2个元素和第三个元素的值插入到v.end()位置中，因为此时v还是空的，所以这里也是往空vector里插入了两个元素。这里只插入了两个元素，而没有插入3个元素

##### vector的内存管理与效率
1.使用reserve()函数提前设定容量大小  
　　关于STL容器，最令人称赞的特性之一就是只要不超过他们的最大值，就可以自动增长到足以容纳用户放进去的数据的大小。（这个最大容量值，只要调用名加max_size的成员函数就可以获得），对于vector和string，如果需要更多的空间，就会以类似realloc的思想来增长大小。vector容器支持随机访问，因此为了提高效率，它内部是使用动态数组的方式实现的。在通过reserve()函数来申请特定大小的内存空间时候总是按指数边界来增长其内部缓冲区。当进行insert或push_back等增加元素的操作时，如果此时动态数组的内存不够用，就要动态的的重新分配当前大小的1.5——2倍的新内存区，再把愿数组的内容复制过去。所以，在一般情况下，其访问速度同一般的数组相比，只有在重新分配 发生时，其性能才会下降。进行pop_back操作时，capacity并不会因为vector容器里的元素减少而有所下降，还会维持操作之前的大小。对于vector容器来数，如果有大量的数据需要进行push_back()，应当使用reserve()函数提前设定其容量大小，否则会出现许多次容量扩充操作，导致效率低下。
  
　　reserve()成员函数允许开发者最小化必须进行的重新分配次数，因而可以避免真分配的开销和迭代器、指针、引用失效。但在解释reserve为什么可以那么做之前需要先简要介绍有时候令人困惑的4个相关成员函数，如下所述。在标准容器中，只有vector和string提供了所有这些函数。
  
　　（1）size()可以获得容器中有多少元素，但不能获得容器为它容纳的元素分配的内存大小。  
　　（2）capacity()可以获得容器在它已经分配的内存中可以容纳多少元素。那是容器在那块内存中总共可以容纳多少元素，而不是还可以容纳多少元素。如果想知道一个vector或string中有多少没有被占用的内存，则必须从capacity()中减去size()。如果size和capacity返回同样的值，容器中就没有剩余空间了，而下一次插入（通过insert或push_back等）会引发上面的重新步骤。
　　（3）resize(Container::size_type n)用来强制把容器改为容纳n个元素。调用resize函数之后，size函数将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入之前会进行重新分配。
　　（4）reserve（Container::size_type n）强制容器把它的容量改为不小于n，提供的n不小于当前所需的大小。因为容量需要增加，这一般会强迫进行一次重新分配。如果n小于当前容量，vector会忽略它，则这个调用什么都不做，string可能把它的容量减少为size()和n中大的数，但string的大小没有变化。
　　综上所述，只要有元素需要插入而且容器的容量不足时就会发生重新分配（包括他们维护的原始内存分配和回收，对象的拷贝和析构和迭代器、指针和引用的失效）。所以，避免重新分配的关键是使用reserve尽快把容器的容量设置为足够大，最好在容器被构造之后立刻进行。

例如，假定想建立一个容纳1-1000值的vector<int>，若不使用reserve,则可以像这样来做:   
```c++
vector<int>v;
for(int i=1;i<=1000;i++)
{
	v.push_back(i);			
}
```
在大多数STL实现中，这段代码在循环过程中将会导致2-10次重新分配。（10这个数没什么奇怪的。记住vector在重新分配发生时一般把容量翻倍，而1000约等于2<sup>10<sup>。）  
把代码改为使用reserve，如下所示：  
```c++
vector<int>v;
v.reserve(1000);
for(int i=1;i<=1000;i++)
{
	v.push_back(i);
}
```

# map
# map基础
# set
# set基础
# STL里的内存池实现
STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池  
二级分配器设计的非常巧妙，分别给8k，16k,...128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存的时候从合适大小的链表中取一块下来。假设需要分配一块10k的内存，那么就找到最小的大于等于10的块，也就是16k，从16k的空闲链表里取出一个用于分配，释放该块内存时，将内存节点归还给链表  
如果要分匹配的内存大于128k则直接调用一级分配器  
为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示节点的地址

# STL里set和map是基于什么实现的，红黑树的特点
1.set和map是基于红黑树实现的。  
2.红黑树是一种平衡二叉查找树，与AVL树的区别是什么？AVL树是完全平衡树，红黑树基本上平衡的。  
3.为什么选择用红黑树而不用AVL树呢？因为红黑树是平衡树，其插入和删除的效率都是O(logN)，与AVL相比红黑树插入和删除最多只需要3次旋转，而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多了。  
红黑树的定义：  
（1）节点是红色或者黑色
（2）根结点一定是黑色
（3）相连两个结点不能同一种颜色
（4）叶子结点一定是黑色
（5）从根结点到每一个叶子结点的路径上的黑结点数目相同

# string类的实现
String的原型代码如下：  
```c++
class String
{
public:
	String(const char *str = NULL);//普通构造函数
	String(const String &other);//拷贝构造函数
	~String();//析构函数
	String& operator=(const String &other);//赋值函数
	String& operator+(const String &other);//字符串连接
	bool operator==(const String &other);//判断相等
	int getLength();//返回长度
private:
	char *m_data;//私有变量保存字符串
};
```
从上述程序可以看到，string类其实是一个对字符串指针有一系列操作动作的的类，也就是说，string类的底层是一个字符串指针。
# 普通构造函数

```c++
String::String(const char* str)
{
	if (str == NULL) 
	{
		m_data = new char[1];
		*m_data = '\0';
		//对空字符串自动申请存放结束标识'\0'的加分点，对m_data加NULL判断
	}
	else
	{
		int length = strlen(str);
		m_data = new char[length + 1];
		strcpy(m_data, str);
	}
}
```
普通构造函数里需要注意的是，传入的是个char* 类型的字符串。如果传入的str是个空的字符串，那这个string就也是一个空的字符串，直接用\0赋值。如果传入的str是非空字符串，私有变量m_data就需要预留length+1的长度，其中“+1”是用来放最后的'\0'的，因为strlen计算字符串长度时，没把'\0'算进去

# String的析构函数

```c++
String::~String()
{
	if (m_data)
	{
		delete[] m_data;//或delete m_data
		m_data = 0;
	}
}
```
析构函数的主要功能是删除成员变量，需要先判断字符串指针是否为空，如果不为空，再将其删除，并将其指向NULL


# 拷贝构造函数

```c++
String::String(const String& other)//输入参数为const
{
	if (!other.m_data)//对m_data加NULL判断
	{
		m_data = 0;
	}
	m_data = new char[strlen(other.m_data) + 1];
	strcpy(m_data, other.m_data);
}
```
拷贝构造函数里需要注意的是，传入的参数是个常引用，这样可以不用新增一个栈变量和参数内容可以保持不变，不被修改


# 赋值函数

```c++
String& String::operator=(const String &other)
{
	//输入参数为const型
	if (this != &other)//检查是否自赋值
	{
		delete[] m_data;//释放原有的内存资源
		if (!other.m_data)//对m_data作NULL判断
		{
			m_data = 0;
		}
		else
		{
			m_data = new char[strlen(other.m_data) + 1];
			strcpy(m_data, other.m_data);
		}
	}
	return *this;//返回本对象的引用
}
```
赋值函数里需要注意的是，如果传入的参数内容已与本身的内容一致，则不需要赋值。如果传入的参数内容与本身内容不一致，需要先清空本身的内容。

# 字符串连接

```c++
String& String::operator+(const String &other)
{
	String newString;
	if (!other.m_data)
	{
		newString = *this;
	}
	else if (!m_data)
	{
		newString = other;
	}
	else
	{
		newString.m_data = new char[strlen(m_data) + strlen(other.m_data) + 1];
		strcpy(newString.m_data, m_data);
		strcpy(newString.m_data, other.m_data);
	}
	return newString;
}
```
字符串连接函数里需要注意的分3种情况：传入的参数内容为空、本身内容为空或两者内容都不为空。

# 判断相等

```
bool String::operator==(const String &other)
{
	if (strlen(m_data) != strlen(other.m_data))
	{
		return false;
	}
	else
	{
		return strcmp(m_data, other.m_data) ? false : true;
	}
}
```
判断相等函数，返回值只有false和true，先判断长度是否一致，再判断内容是否一致

# 返回长度

```
int String::getLength()
{
	return strlen(m_data);
}
```
返回长度函数，只需要strlen直接计算char* 的长度即可。

# c四种类型转换

# static_cast

static_cast用的最多，对于各种隐式转换，非const转const，void* 转指针等，static_cast能用于多态上转化，如果向下转能成功但是不安全，结果未知。

# dynamic_cast

dynamic_cast用于动态类型转化，只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转化的原理

# const_cast

const_cast用于将const变量转化为非const

# reinterpret_cast

reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出现问题，尽量少用


# 重载和重写（覆盖）的区别
从定义上来说：

重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

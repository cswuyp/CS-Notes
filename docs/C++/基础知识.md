* [面向对象的三个基本特征](#面向对象的三个基本特征)
* [虚函数的实现原理](#虚函数的实现原理)
* [怎么用C语言实现虚函数的功能](#怎么用c语言实现虚函数的功能)
* [在C++中的虚函数表是什么时期建立的](#在c中的虚函数表是什么时期建立的)
* [在C++对象内存布局](#在c对象内存布局)
* [在C++自定义的函数一定要先声明或者定义在main函数前面吗？](#在c自定义的函数一定要先声明或者定义在main函数前面吗)
* [sort函数的实现原理](#sort函数的实现原理)
* [malloc函数的实现原理](#malloc函数的实现原理)
* [new实现原理](#new实现原理)
* [拷贝构造函数](#拷贝构造函数)
* [构造函数可否为虚函数](#构造函数可否为虚函数)
* [父类的析构函数为什么要声明为虚函数](#父类的析构函数为什么要声明为虚函数)
* [描述内存分配方式以及它们的区别](#描述内存分配方式以及它们的区别)
* [#const与#define相比，有何优点](#const与define相比有何优点)
* [数组与指针的区别](#数组与指针的区别)
* [引用与指针有什么区别](#引用与指针有什么区别)

* [STL容器的使用](#STL容器的使用)
  * [vector](#vector)
    * [vector基础](#vector基础)
  * [map](#map)
    * [map基础](#map基础)
  * [set](#set)
    * [set基础](#set基础)







# 面向对象的三个基本特征
1.封装  
简单来讲：将现实世界的事物抽象成计算机领域中的对象，对象同时具有属性和行为，这种抽象就是封装。  
封装的一个重要特性：数据隐藏，对象只对外提供与其它对象交互的必要接口，而将自身的某些属性和实现细节对外隐藏，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或者错误的使用了对象的私有部分，这样就在确保正常交互的前提下，保证了安全性。  
2.继承  
面向对象的一个重要特性是复用性，继承是实现复用性的一个重要手段，可以在不重复编写以实现的功能的前提下，对功能进行复用和拓展。  
继承概念的实现方式有两类：实现继承与接口继承  
实现继承是指直接使用基类的属性和方法而无需额外编码的能力。  
接口继承是指仅使用属性和方法的名称，但是子类必须提供实现的能力。  
3.多态  
当存在继承关系时，允许将父类对象看成和它的一个或多个子类对象等同，这样可以根据当前赋给父类对象的子类对象的具体特性以不同的方式进行运行，  
多态的几个前提  
a.要有继承关系  
b.要有方法重写  
c.要有父类引用指向子类对象  
多态的好处  
a.提高了代码的维护性（继承保证）  
b.提高了代码的扩展性（由多态保证）  
多态的限制  
不能使用子类的特有属性和行为  

# 虚函数的实现原理

我们可以从虚函数表和虚函数指针来了解虚函数的实现原理。  
简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。
含有虚函数的类会
http://www.cnblogs.com/malecrab/p/5572730.html

# 怎么用C语言实现虚函数的功能
参照前面C++虚函数的实现原理，可以自己添加虚函数指针和虚函数表来实现虚函数功能。  

# 在C++中的虚函数表是什么时期建立的
虚函数表是编译期确定的，虚函数表中存放的是虚函数的地址，而虚函数的地址是在编译期间就确定的所以虚函数表应该也是在编译期就确定的。 
我们在《深度探索C++对象模型》的4.2节能够找到完美的答案，具体摘抄如下：  
“表格中的virtual functions地址是如何构建起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或者替换之。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完美掌控，不需要执行期的任何介入。”

# 在C++对象内存布局
https://www.cnblogs.com/wuyepeng/p/9863296.html

# 在C++自定义的函数一定要先声明或者定义在main函数前面吗？
不一定，C++中的执行总是从main函数开始的（无论main放在什么位置），如果自定义的函数放于main函数之后则需要在main函数前声明该自定义函数，如果自定义的函数放于main函数前则不需要额外的声明，否则在main函数中调用该自定义函数时会出现无法识别。


# sort函数的实现原理
　　STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。
  
# malloc函数的实现原理
https://blog.csdn.net/hudazhe/article/details/79535220

# new实现原理
　　当我们使用关键字new在堆上动态创建一个对象时，它实际上做了三件事：（1）获得一块内存空间，（2）调用构造函数，（3）返回正确的指针。
  https://blog.csdn.net/xxpresent/article/details/53024555
  
# 拷贝构造函数

# 构造函数可否为虚函数


# 父类的析构函数为什么要声明为虚函数
1：每个析构函数只会清理自己的成员（成员函数前没有virtual）。

2：可能是基类的指针指向派生类的对象，当析构一个指向派生类的成员的基类指针，这时程序不知道这么办，可能会造成内存的泄露，因此此时基类的析构函数要定义为虚函数； 基类指针可以指向派生类的对象（多态），如果删除该指针delete[]p，就会调用该指针指向的派生类的析构函数，而派生类的对象又会自动调基类的成员函数，这样就会把派生类的对象释放，如果基类的析构函数没有定义成虚函数，则编译器实现的静态绑定，在删除基类的指针，只会释放基类的析构函数而不会释放派生类的成员函数，此时会导致释放内存不完全，就会导致内存泄露的问题。 

# 描述内存分配方式以及它们的区别

# #const与#define相比，有何优点

# 数组与指针的区别

# 引用与指针有什么区别


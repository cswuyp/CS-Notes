* [IO多路复用](#io多路复用)
  * [1.select系统调用](#1-select系统调用)
  * [2.poll系统调用](#2-poll系统调用)
  * [3.epoll系统调用](#3-epoll系统调用)  

* [I/O复用函数的比较](#io复用函数的比较)
# IO多路复用
　　I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。通常网络程序在下列情况下需要使用I/O复用技术：  
1.客户端程序要同时处理多个socket。  

2.客户端程序要同时处理用户输入和网络连接。  

3.TCP服务器要同时处理监听socket和连接socket。这是I/O复用使用最多的场合。  

4.服务器要同时处理TCP请求和UDP请求。  

5.服务器要同时监听多个端口，或者处理多种服务。  

　　只要指出的是，I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。
  
　　Linux下实现I/O复用的系统调用主要有select、poll和epoll。
  
  # 1. select系统调用
  select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。
  https://www.cnblogs.com/wuyepeng/p/9740240.html  
  https://www.cnblogs.com/wuyepeng/p/9745573.html  
  https://www.cnblogs.com/wuyepeng/p/9726771.html  
  
  ## 文件描述符就绪条件
  哪些情况下文件描述符可以被认为是可读、可写、或者出现异常，对于select的使用非常关键。在网络编程中，下列情况下socket可读：  
  1.socket内核接收缓存区中的字节数大于或等于其低水平位标记SO_RCVLOWAT。此时我们可以无阻塞的地读该socket，并且读操作返回的字节数大于0.  
  2.socket通信的对方关闭连接。此时对该socket的读操作将返回0.  
  3.监听socket上有新的连接请求。  
  4.socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。  
  下来情况下socket可写：  
  5.socket内核发送缓存区中的可用字节数大于或等于其低水平位标记SO_SNDLOWAT。此时我们可以无阻塞地写socket，并且写操作返回的字节数大于0.  
  6.socket的写操作被关闭，对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。  
  7.socket使用非阻塞connect连接成功或者失败（超时）之后。  
  8.socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。  
  网络程序中，select能处理的异常情况只有一种：socket上接收到外数据。
  
  
  # 2. poll系统调用
  poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。
  https://www.cnblogs.com/wuyepeng/p/9751087.html
  
  
  
  
  # 3. epoll系统调用
  epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无序像select和poll那样每次调用都需重复传入文件描述符集和事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用如下epoll_create函数来创建：
  ```c++
  #include<sys/epoll.h>
  int epoll_create(int size)
  ```
  https://www.cnblogs.com/wuyepeng/p/9727085.html
  
  # I/O复用函数的比较
   系统调用|select|poll|epoll
  ---|:--:|:--:|---:
  事件集合|用户通过3个参数分别传入感兴趣的可读、可写及异<br>常等事件，内核通过对这些参数的在线修改来反馈其中<br>的就绪事件。这使得用户每次调用select都要重置这3<br>个参数|统一处理所有事件类型，因此只需要一个事件集参数。<br>用户通过poll.events传入感兴趣的事件，内核通过<br>修改pollfd.revents反馈其中就绪的事件|内核通过一个事件表直接管理用户感兴趣的所有<br>事件。因此每次调用epoll_wait时，无须反复传入用户感兴趣的事件。epoll_wait<br>系统调用的参数events仅用来反馈就绪的事件。
应用程序索引就绪文件<br>描述符的时间复杂度|O(n)|O(n)|O（1）
最大支持文件描述符数|一般有最大值限制|65535|65535
工作模式|LT|LT|支持ET高效模式
内核实现和工作效率|采用轮询方式来检测就绪事件，算法时间复杂度为O(n)|采用轮询方式来检测就绪事件，算法时间复杂度为O(n)|采用回调方式来检测就绪事件，算法时间复杂度为O(1)

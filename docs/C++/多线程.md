* [1.简单多线程实例](#1-简单多线程实例)
* [2.子进程继承自父进程什么](#2-子进程继承自父进程什么)
* [3.如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢](#3-如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢)
# 1. 简单多线程实例
```c++
#include <iostream>
#include<thread>
using namespace std;
void foo()
{
	for (int i = 0; i < 100; i++)
	{
		cout << "foo() i:" << i << endl;
	}
}
void bar(int x)
{
	for (int j = x; j < 200; j++)
	{
		cout << "bar():j" << j << endl;
	}
}
int main()
{
	thread first(foo);
	thread second(bar,100);
	first.join();
	second.join();
	return 0;
}
```
# 2. 子进程继承自父进程什么
子进程继承父进程
--------------
1.用户号UIDs和用户组号GIDs   
2.环境Environment   
3.堆栈   
4.共享内存   
5.打开文件的描述符   
6.执行时关闭（Close-on-exec）标志   
7.信号（Signal）控制设定   
8.进程组号   
9.当前工作目录   
10.根目录   
11.文件方式创建屏蔽字   
12资源限制   
13.控制终端  

子进程独有
--------
1.进程号PID   
2.不同的父进程号   
3.自己的文件描述符和目录流的拷贝   
4.子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）   
5.不继承异步输入和输出  
6.父进程和子进程拥有独立的地址空间和PID参数。  

# 3. 如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢
　　答案是：否。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。这就引起一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁。不过，pthread提供了一个专门的函数pthread_atfork，以确保fork调用后父进程和子进程都拥有一个清楚的锁状态。
  
　　该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。prepare句柄将在fork调用创建出子进程之前执行。它可以用来锁住所有父进程中的互斥锁。parent句柄则是fork调用创建出子进程之后，而fork返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。child句柄是fork返回之前，在子进程中被执行。和parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的互斥锁。该函数成功时返回0，失败则返回错误码。
  

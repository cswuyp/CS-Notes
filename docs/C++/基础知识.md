* [面向对象的三个基本特征](#面向对象的三个基本特征)
* [虚函数的实现原理](#虚函数的实现原理)
* [怎么用C语言实现虚函数的功能](#怎么用c语言实现虚函数的功能)
* [在C++中的虚函数表是什么时期建立的](#在c中的虚函数表是什么时期建立的)
* [在C++对象内存布局](#在c对象内存布局)
* [在C++自定义的函数一定要先声明或者定义在main函数前面吗？](#在c自定义的函数一定要先声明或者定义在main函数前面吗)
* [sort函数的实现原理](#sort函数的实现原理)
* [malloc函数的实现原理](#malloc函数的实现原理)
* [new实现原理](#new实现原理)
* [new和malloc的区别](#new和malloc的区别)
* [free实现原理](#free实现原理)
* [delete实现原理](#delete实现原理)
* [realloc扩容的原理](#realloc扩容的原理)
* [拷贝构造函数](#拷贝构造函数)
* [构造函数可否为虚函数](#构造函数可否为虚函数)
* [父类的析构函数为什么要声明为虚函数](#父类的析构函数为什么要声明为虚函数)
* [描述内存分配方式以及它们的区别](#描述内存分配方式以及它们的区别)
* [#const与#define相比，有何优点](#const与define相比有何优点)
* [数组与指针的区别](#数组与指针的区别)
* [引用与指针有什么区别](#引用与指针有什么区别)
* [野指针](#野指针)
* [初始化列表初始化](#初始化列表初始化)
* [必须在构造函数初始化列表中进行初始化的数据成员有哪些](#必须在构造函数初始化列表中进行初始化的数据成员有哪些)
* [构造函数初始化](#构造函数初始化)
* [const的作用](#const的作用)
* [const成员函数的使用](#const成员函数的使用)
* [动态创建数组](#动态创建数组)
* [内联函数有什么优点,内联函数与宏定义的区别](#内联函数有什么优点内联函数与宏定义的区别)
* [static关键字作用](#static关键字作用)
* [static成员函数的使用](#static成员函数的使用)
* [右值引用](#右值引用)
* [移动构造函数](#移动构造函数)




* [STL容器的使用](#STL容器的使用)
  * [vector](#vector)
    * [vector基础](#vector基础)
  * [map](#map)
    * [map基础](#map基础)
  * [set](#set)
    * [set基础](#set基础)
* [STL里的内存池实现](#stl里的内存池实现)
* [STL里set和map是基于什么实现的，红黑树的特点](#stl里set和map是基于什么实现的红黑树的特点)


* [智能指针](#智能指针)
  * [auto_ptr](#auto_ptr)
  * [unique_ptr](#unique_ptr)
  * [weak_ptr](#weak_ptr)
  * [share_ptr](#share_ptr)

* [C++四种类型转换](#c四种类型转换)
  * [static_cast](#static_cast)
  * [dynamic_cast](#dynamic_cast)
  * [const_cast](#const_cast)
  * [reinterpret_cast](#reinterpret_cast)

# 面向对象的三个基本特征
1.封装  
简单来讲：将现实世界的事物抽象成计算机领域中的对象，对象同时具有属性和行为，这种抽象就是封装。  
封装的一个重要特性：数据隐藏，对象只对外提供与其它对象交互的必要接口，而将自身的某些属性和实现细节对外隐藏，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或者错误的使用了对象的私有部分，这样就在确保正常交互的前提下，保证了安全性。  
2.继承  
面向对象的一个重要特性是复用性，继承是实现复用性的一个重要手段，可以在不重复编写以实现的功能的前提下，对功能进行复用和拓展。  
继承概念的实现方式有两类：实现继承与接口继承  
实现继承是指直接使用基类的属性和方法而无需额外编码的能力。  
接口继承是指仅使用属性和方法的名称，但是子类必须提供实现的能力。  
3.多态  
当存在继承关系时，允许将父类对象看成和它的一个或多个子类对象等同，这样可以根据当前赋给父类对象的子类对象的具体特性以不同的方式进行运行，  
多态的几个前提  
a.要有继承关系  
b.要有方法重写  
c.要有父类引用指向子类对象  
多态的好处  
a.提高了代码的维护性（继承保证）  
b.提高了代码的扩展性（由多态保证）  
多态的限制  
不能使用子类的特有属性和行为 

多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。
动态多态实现有几个条件：  
(1) 虚函数；  
(2) 一个基类的指针或引用指向派生类的对象；  
基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。  
每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。  
虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。      
编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。  

# 虚函数的实现原理

我们可以从虚函数表和虚函数指针来了解虚函数的实现原理。  
简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。
含有虚函数的类会
http://www.cnblogs.com/malecrab/p/5572730.html

# 怎么用C语言实现虚函数的功能
参照前面C++虚函数的实现原理，可以自己添加虚函数指针和虚函数表来实现虚函数功能。  

# 在C++中的虚函数表是什么时期建立的
虚函数表是编译期确定的，虚函数表中存放的是虚函数的地址，而虚函数的地址是在编译期间就确定的所以虚函数表应该也是在编译期就确定的。 
我们在《深度探索C++对象模型》的4.2节能够找到完美的答案，具体摘抄如下：  
“表格中的virtual functions地址是如何构建起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或者替换之。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完美掌控，不需要执行期的任何介入。”

# 在C++对象内存布局
https://www.cnblogs.com/wuyepeng/p/9863296.html

# 在C++自定义的函数一定要先声明或者定义在main函数前面吗？
不一定，C++中的执行总是从main函数开始的（无论main放在什么位置），如果自定义的函数放于main函数之后则需要在main函数前声明该自定义函数，如果自定义的函数放于main函数前则不需要额外的声明，否则在main函数中调用该自定义函数时会出现无法识别。


# sort函数的实现原理
　　STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。
  
# malloc函数的实现原理
https://blog.csdn.net/hudazhe/article/details/79535220

# new实现原理
　　当我们使用关键字new在堆上动态创建一个对象时，它实际上做了三件事：（1）获得一块内存空间，（2）调用构造函数，（3）返回正确的指针。
  https://blog.csdn.net/xxpresent/article/details/53024555
  
# new和malloc的区别
1.new分配内存按照数据类型进行分配，malloc分配内存按照内存大小进行分配。  
2.new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。但是还需要注意的是，之前看过一个题说int p=new int与int p=new int()的区别，因为int属于C++内置对象，不会默认初始化，必须显示调用构造函数，但是对于自定义对象都会默认调用构造函数初始化。翻阅资源后，在C++11中两者没有区别了，自己测试的结构也都是为0；  
3.new返回的是指定对象的指针，而malloc返回的是void* 因此，malloc的返回值一般都需要进行类型转化。  
4.new是一个操作符可以重载，malloc是一个库函数。  
5.new分配的内存要用delete销毁，malloc要用free来销毁，delete销毁的时候会调用对象的析构函数，而free则不会。  
6.malloc分配的内存不够的时候，可以用realloc扩容，new没有这样的操作。  
7.new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try...catch语法，而malloc则应该判断指针的返回值。为了兼容很多C程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL  
8.new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int)* n  
9如果不够可以继续谈new和malloc的实现，空闲链表，分配方法（首次适配原则，最佳适配原则，最差适配原则，快速适配原则）delete和free的实现原理。

# free实现原理

# delete实现原理


# realloc扩容的原理


# 拷贝构造函数
### 什么时候需要自己定义拷贝构造函数，以避免浅拷贝问题？  
一般情况下，当类中成员有指针变量，类中有动态内存分配时常常需要用户自己定义拷贝构造函数。  
### 在什么情况下系统会调用拷贝构造函数（三种情况）  
（1）用类的一个对象去初始化另一个对象  
（2）当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用  
（3）当函数的返回值是类的对象或引用时

# 构造函数可否为虚函数


# 父类的析构函数为什么要声明为虚函数
1：每个析构函数只会清理自己的成员（成员函数前没有virtual）。

2.为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，当对象销毁时会自动调用基类的析构函数，如果此时基类的析构函数为虚函数才会再调用基类指针指向的派生类的析构函数，否则不会调用派生类的析构函数造成内存泄露。

# 描述内存分配方式以及它们的区别

# #const与#define相比，有何优点

# 数组与指针的区别

# 引用与指针有什么区别
1.指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问。  
2.指针可以改变地址，从而改变所指的对象，而引用一经初始化就不可更改  
3.引用在定义时必须初始化，而指针则不需要。  
4.指针有指向常量的指针和指针常量，而引用没有常量引用    
5.指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全很多但是比较死板。  


# 野指针

# 初始化列表初始化

# 必须在构造函数初始化列表中进行初始化的数据成员有哪些
（1）常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面  
（2）引用成员，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面  
（3）没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
# 构造函数初始化


# const的作用
1.const修饰全局变量  
2.const修饰局部变量  
3.const修饰指针，const int*  
4.const修饰指针指向的对象，int * const;    
5.const修饰引用该做形参  
6.const修饰成员变量，必须在构造函数列表中初始化  
7.const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变

# const成员函数的使用

# 动态创建数组


# 内联函数有什么优点,内联函数与宏定义的区别
1.宏定义在预编译的时候就会进行宏替换  
2.内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译（内联是给编译器的一个建议编译器可以不听）    
3.内联函数相对比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。  
4.使用宏定义函数要特别注意给所有单元都加上括号，否则很容易出错

# static关键字作用
1.static修饰局部变量。  
2.static修饰全局变量。  
3.static修饰普通函数。  
4.static修饰成员函数。  
5.static修饰成员变量。


# STL容器的使用
# vector
# vector基础
# map
# map基础
# set
# set基础
# STL里的内存池实现
STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池  
二级分配器设计的非常巧妙，分别给8k，16k,...128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存的时候从合适大小的链表中取一块下来。假设需要分配一块10k的内存，那么就找到最小的大于等于10的块，也就是16k，从16k的空闲链表里取出一个用于分配，释放该块内存时，将内存节点归还给链表  
如果要分匹配的内存大于128k则直接调用一级分配器  
为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示节点的地址

# STL里set和map是基于什么实现的，红黑树的特点
1.set和map是基于红黑树实现的。  
2.红黑树是一种平衡二叉查找树，与AVL树的区别是什么？AVL树是完全平衡树，红黑树基本上平衡的。  
3.为什么选择用红黑树而不用AVL树呢？因为红黑树是平衡树，其插入和删除的效率都是O(logN)，与AVL相比红黑树插入和删除最多只需要3次旋转，而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多了。  
红黑树的定义：  
（1）节点是红色或者黑色
（2）根结点一定是黑色
（3）相连两个结点不能同一种颜色
（4）叶子结点一定是黑色
（5）从根结点到每一个叶子结点的路径上的黑结点数目相同

# static成员函数的使用

# 右值引用

# 移动构造函数

# c四种类型转换

# static_cast

static_cast用的最多，对于各种隐式转换，非const转const，void* 转指针等，static_cast能用于多态上转化，如果向下转能成功但是不安全，结果未知。

# dynamic_cast

dynamic_cast用于动态类型转化，只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转化的原理

# const_cast

const_cast用于将const变量转化为非const

# reinterpret_cast

reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出现问题，尽量少用

* [Python内存管理](#python内存管理)

# Python内存管理
Python内部使用了引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。

总结一下对象在以下情况下引用计数加1：  
1.对象被创建： x=4  
2.另外的别人被创建 y=x  
3.被作为参数传递给函数 foo(x)  
4.作为容器对象的一个元素 a=[1,x,'33']  

引用计数减少情况：  
1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1  
2.对象的别名被显示的销毁： del x  
3.对象的一个别名被赋值给其他对象： x=789  
4.对象从一个窗口对象中移除，myList.remove(x)  
5.窗口对象本身被销毁，del myList 或者窗口对象本身离开了作用域

### 垃圾回收
1.当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉，当两个对象互相引用时，他们本身其他的引用已经为0了。

2.垃圾回收机制还有一个循环垃圾回收器，确保释放循环引用对象（a引用b，b引用a，导致引用计数永远不为0）

在Python中，许多时候申请的内存都是小块的内存，这些小块的内存在申请后，很快又会被释放，由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和内核态之间进行切换，这将严重影响Python的执行效率，为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

### 内存池机制
Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。  
Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。另外Python对象，如整数，浮点数和List都有其独立的私有内存池，对象间不共享他们的内存池，也就是说如果你分匹配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

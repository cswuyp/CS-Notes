* [简单多线程实例](#简单多线程实例)
* [子进程继承自父进程什么](#子进程继承自父进程什么)
* [如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢](#如果一个多线程程序的某个线程调用了fork函数那么新创建的子进程是否将自动创建和父进程相同数量的线程呢)
* [进程池和线程池](#进程池和线程池)
* [进程编程实例](#进程编程实例)
* [进程和线程之间的区别](#进程和线程之间的区别)
* [线程安全](#线程安全)
* [线程共享资源和独占资源问题](#线程共享资源和独占资源问题)
# 1. 简单多线程实例
```c++
#include <iostream>
#include<thread>
using namespace std;
void foo()
{
	for (int i = 0; i < 100; i++)
	{
		cout << "foo() i:" << i << endl;
	}
}
void bar(int x)
{
	for (int j = x; j < 200; j++)
	{
		cout << "bar():j" << j << endl;
	}
}
int main()
{
	thread first(foo);
	thread second(bar,100);
	first.join();
	second.join();
	return 0;
}
```
# 2. 子进程继承自父进程什么
子进程继承父进程
--------------
1.用户号UIDs和用户组号GIDs   
2.环境Environment   
3.堆栈   
4.共享内存   
5.打开文件的描述符   
6.执行时关闭（Close-on-exec）标志   
7.信号（Signal）控制设定   
8.进程组号   
9.当前工作目录   
10.根目录   
11.文件方式创建屏蔽字   
12资源限制   
13.控制终端  

子进程独有
--------
1.进程号PID   
2.不同的父进程号   
3.自己的文件描述符和目录流的拷贝   
4.子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）   
5.不继承异步输入和输出  
6.父进程和子进程拥有独立的地址空间和PID参数。  

# 3. 如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢
　　答案是：否。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。这就引起一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁。不过，pthread提供了一个专门的函数pthread_atfork，以确保fork调用后父进程和子进程都拥有一个清楚的锁状态。
  
　　该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。prepare句柄将在fork调用创建出子进程之前执行。它可以用来锁住所有父进程中的互斥锁。parent句柄则是fork调用创建出子进程之后，而fork返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。child句柄是fork返回之前，在子进程中被执行。和parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的互斥锁。该函数成功时返回0，失败则返回错误码。
  
# 4. 进程池和线程池
动态创建子进程（或子线程）来实现并发服务器的缺点如下：  
1.动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户反应。  
2.动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量的CPU时间。  
3.动态创建的子进程是当前进程的的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。  

进程池的实现原理：  
　　进程池是由服务器预先创建的一组子进程，（线程池中的线程数量应该和CPU数量差不多）。进程池中的所有子进程都运行这相同的代码，并且有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即他们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。  
　　当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态的创建子进程，选择一个已存在的子进程的代价显然要小得多。至于主进程选择哪一个子进程来为新任务服务，则有两种方式：  
1.主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力。  
2.主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠的工作队列上。  
　　当选择好子进程后，主进程还需要使用某种通知进制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使用）。在父线程和子线程之间传递数据要简单得多，因为我们可以把这些数据定义为全局的，那么他们本身就是被所有线程共享的。  
　　用途：  
1.需要大量的线程来完成任务，且完成任务时间比较短，比如WEB服务器完成网页请求这样的任务，使用线程池技术是非常适合的。因为单个任务小，而任务数量巨大，但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Tenlnet会话时间比线程的创建时间大多了。  
2.对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。  
3.接收突发性的大量请求，但不至于使服务器因此产生线程的应用。  

[基于C++11实现线程池的工作原理](https://www.cnblogs.com/ailumiyana/p/10016965.html)

# 5. 进程编程实例
进程编程实例1：  
```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include<stdio.h>
int main()
{
        pid_t child_pid;

        /* 创建一个子进程 */
        child_pid = fork();
        if(child_pid == 0)
        {
                printf("child pid\n");
                exit(0);
        }
        else
        {
                printf("father pid\n");
                sleep(60);
        }

        return 0;
}
```

# 6. 进程和线程之间的区别
进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统的基本单位。  
线程：是进程的一个执行单元，是进程内调度实体，比进程更小的独立运行的基本单位。线程也称为轻量级进程。  
一个程序至少一个进程，一个进程至少一个线程。  
根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

# 线程安全
如果你的代码所在的线程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也是和预期的是一样的，就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步问题。

线程安全问题都是由全局变量及静态变量引起的。  
若每个线程中对全局变量，静态变量只有读操作，而无写操作，一般来说，这个线程是安全的，若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

# 线程共享资源和独占资源问题
一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的/私有的栈  
线程共享资源：地址空间，全局变量，打开的文件，子进程，闹钟，信号及信号服务程序，记账信息  
线程独占资源：程序计数器，寄存器，栈，状态字  

* [1.TCP三次握手和四次挥手](#1-tcp三次握手和四次挥手)
* [2.TCP和UDP的区别](#2-tcp和udp的区别)





# 1. TCP三次握手和四次挥手
TCP的运输连接管理

　　TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。

　　在TCP连接建立过程中要解决以下三个问题：

　　（1）要使每一方能够确知对方的存在

　　（2）要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）

　　（3）能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配

　　TCP连接的建立采用客户服务器方式。主动发起连接的建立的应用进程叫做客户（client），而被动等待连接建立的应用进程叫做服务器（server）。

TCP的连接建立

　　TCP建立连接的过程叫做握手，握手    
  <div align="center"> <img src="./TCP三次握手.png" width="600"/> </div><br>

TCP连接释放过程比较复杂，我们仍然结合双方状态的改变来阐明连接释放的过程。

　　数据传输结束后，通信的双方都可以释放连接。现在A和B都处于ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确定。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。
  
<div align="center"> <img src="./TCP四次挥手.png" width="600"/> </div><br>

　　B收到连接释放报文段后即发出确定，确定号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1.然后B就进入CLOSEWAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接释放处于半关闭状态，即A已经没有数据要发送了，但 B若发送数据，A仍然要接收。这就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。

　　A收到来自B的确认后，就进入FIN-WAIT（终止等待2）状态，等待B发出的连接释放报文段。

　　若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时候B发出的连接释放报文必须使FIN=1.现假定B的序号为w（在半关闭状态B可能又发送一些数据）。B还必须重复上次已发送过的确认号ack=u+1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。

　　A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而子集的序号是seq=u+1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间2MASL后，ACIA进入到CLOSED状态。时间MSL叫做最长报文段寿命，RFC793建议设为2分钟。但这完全是从 工程上来考虑的，对于现在的网络，MSL=2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用最小的MSL值。因此，从A进入到TIME-WAIT状态后，要经过4分钟才能进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。

　　为什么A在TIME-WAIT状态必须等到2MSL的时间？这有两个理由。

答：第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后A和B都正常进入到CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而不会再发送一次 确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。

　　第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中 消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

　　B只有收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的传输控制块TCB后就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间比A早一些。

 

出现太多TIME_WAIT可能导致的后果：  
    在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
我来解释下这个场景。主动正常关闭TCP连接，都会出现TIMEWAIT。为什么我们要关注这个高并发短连接呢？有两个方面需要注意：

 ① 高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
 ②在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。这里有个相对长短的概念，比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高）
     综合这两个方面，持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。



# 2. TCP和UDP的区别



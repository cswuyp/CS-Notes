* [死锁](#死锁)
* [内存池](#内存池)
* [进程调度](#进程调度)
* [孤儿进程和僵死进程](#孤儿进程和僵死进程)
* [分页式内存管理](#分页式内存管理)
* [分段式内存管理](#分段式内存管理)
* [段页式内存管理](#段页式内存管理)
* [什么是虚拟内存](#什么是虚拟内存)
* [页面置换算法](#页面置换算法)
* [颠簸](#颠簸)
* [虚拟内存的作用](#虚拟内存的作用)
* [虚拟内存的实现](#虚拟内存的实现)
* [Linux如何避免内存碎片化](#linux如何避免内存碎片化)
* [内部碎片和外部碎片](#内部碎片和外部碎片)
# 死锁
### 什么是死锁
死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。例如，在某一个计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印设备的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程互相无休无止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。

### 死锁产生的原因
1.系统资源的竞争  
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。  
2.进程运行推进顺序不适当  
进程在运行过程中，请求和释放资源的顺序不当，会导致死锁

### 死锁产生的条件
1.互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。  

2.请求与保持条件：进程已经保持了至少一各资源，但又提出了新的资源的请求，而该资源已被其他进程所占有，此时请求进程被阻塞，但对自己已获得的资源保持不。  
3.不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是自己释放）

4.循环等待条件：若干进程间形成首尾相接循环等待资源的关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

### 处理死锁的方法
1.预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防死锁的发生。

2.避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。

3.检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除

4.解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来

#### 预防死锁
1.破坏“互斥”条件  
就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。  
注意：互斥条件不能被破坏，否则会造成结果的不可再现性

2.破坏“占有并等待”条件  
破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。  
方法一：创建进程时，要求它申请所需的全部资源、系统或满足其所要求，或什么都不给它。这是所谓的“一次性分配”方案。  
方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对资源S的申请，即使它可能很快又要用到资源R。

3.破坏“不可抢占”条件  
破坏“不可抢占”条件是允许对资源实行抢夺  
方法一：如果占有某些资源的一个进程进行进一步资源申请被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。  
方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只要在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。  

4.破坏“循环等待”条件  
破坏“循环等待”条件的一种方法，是将系统的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。

#### 避免死锁
预防死锁和避免死锁的区别：  
预防死锁是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现，而避免死锁则不那么严格的限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。

1.有序资源分配法  
这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1，磁带机为2，磁盘为3等）申请时必须以上升的次序。系统要求申请进程：  
（1）对它所必须使用的而且属于同一类的所有资源，必须一次申请完。  
（2）在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2.进程PB，使用资源的顺序是R2,R1若采用动态分配有可能形成环路条件，造成死锁。  
采用有序资源分配法：R1的编号为1，R2的编号为2；  
PA：申请次序是:R1,R2  
PB：申请次序是：R1,R2  
这样就破坏了环路条件，避免了死锁的发生

2.银行家算法  
当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。  
四个条件：  
1.分批向银行贷款时，申请的总额不能超过一开始申请的额度。  
2.申请贷款时不能超过银行现有资金的数目。  
3.当银行资金不能满足顾客贷款需求时，可以推迟支付，但是肯定会让顾客在需求时间内得到贷款。  
4.顾客拿到贷款后必须在规定时间内归还

3.系统安全状态法  
即在分配资源之前，就应该检测此次资源分配的安全性，如果此次分配资源会导致进程进入不安全状态，那就等待，如果不会，则分配资源

# 内存池
　　内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不是将内存返回给操作系统，而是返回内存池，当程序退出（或者特点时间）时，内存池才将之前申请的内存真正释放。
### 默认的内存管理函数的不足
1.malloc/free和new/delete在堆上申请和释放的内存都有一定的额外开销。

2.开销来自维护内存空闲块表

3.malloc和new申请堆内存时，首先查找内部维护的空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配

4.类似地，在free和delete释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块结合并成较大的空闲块。

5.默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销

6.可见，如果应用程序频繁地在堆上分配和释放内存，则会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率

7.默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池则可以获得更好的性能。

### 内存池的定义
　　应用程序可以通过调用系统的内存分配函数预先一次性申请适当大小的内存作为一个内存池，并为这个内存池或结构体定义一些分配和释放内存块的成员函数。之后应用程序自己对内存的分配和释放则可以通过这个内存池及其成员函数来完成。只有的那个内存池大小需要动态扩展时，才需要再调用系统的内存分配函数，其他时间对内存的一切操作都在应用程序的掌控之中。
  
### 内存池的分类
1）从线程安全角度分为单线程内存池和多线程内存池  
-----
单线程内存池整个生命周期只被一个线程使用，因而不需要考虑互斥访问的问题。  

多线程内存池有可能被多个线程共享，因此需要在每次分配和释放内存时加锁

相对而言，单线程内存池性能更高，而多线程内存池适用范围更广

2）从内存池可分配内存单元大小来分为固定内存池和可变内存池  
-----------
固定内存池是指应用程序每次从内存池中分配出来的内存单元大小事先已经确定，是固定不变的，维护起来方便，性能更高

而可变内存池则每次从内存池中分配出来的内存单元大小可以按需变化，应用范围更广，而性能比固定内存池要低。

###  固定内存池工作原理
固定内存池由一系列固定大小的内存块组成，每一个内存块又包含了固定数量和大小的内存单元。  

 <div align="center"> <img src="./内存池1.jpg" width="600"/> </div><br>

上图中，内存池=4个内存块，一个内存块=块头+3个内存单位

在内存池初次生成时，只向系统申请了一个内存块，返回的指针作为整个内存池的头指针。之后随着应用程序对内存的不断需求，内存池判断需要动态扩大时，才再次向系统申请新的内存块，并把所有这些内存块通过指针链接起来。

对于操作系统来说，它已经为该应用程序分配了4个等大小的内存块。由于是大小固定的，所以分配的速度比较快，而对于应用程序来说，其内存池使用了一定大小的内存单元，内存池内部却还有剩余的空间。

例如放大来看第4个内存块，其中包含一部分内存池块头信息和3个大小相等的内存单元。单元1和单元3是空闲的，单元2已经分配。当应用程序需要通过该内存池分配一个单元大小的内存时，只需要简单遍历所有的内存池块头信息，快速定位到还有空闲单位的那个内存池。  
【注意】：不需要遍历每个内存单元，各个内存块的块头信息中会记录本内存块中管理的内存单元的整体情况。  
然后根据该块的块头信息直接定位到第1个空闲的单元地址，把这个地址返回，并且标记下一个空闲单元即可，当应用程序释放某一个内存池单元时，直接在对应的内存池块信息中标记该内存单元为空闲单元即可  

### 与系统内存管理相比，内存池的操作非常迅速，性能优化方面的优点如下：  
（1）针对特殊情况，例如需要频繁分配释放固定大小的内存对象时，不需要复杂的分配算法和多线程/多进程保护（系统内存管理一直会加锁解锁）。也不需要维护内存空闲表的额外开销，只需要维护简单的内存池块头信息，从而获得较高的性能。  

（2）由于开辟一定数量的连续内存空间作为内存池块，因而一定程序上提高了程序局部性和数据访问的速度，提高了程序性能。  

（3）比较容易控制页边界对齐和内存对齐字节，没有内存碎片的问题。

### 一个单线程的固定内存池的实现
这是一个应用于单线程环境且分配单元大小固定的内存池，一般用来为执行时会动态频繁地创建且可能会被多次创建的类对象或者结构体分配内存

 <div align="center"> <img src="./内存池2.jpg" width="600"/> </div><br>

内存池类MemoryPool的声明如下：
```c++
class MemoryPool
{
private:
    MemoryBlock*   pBlock;            //内存池中内存块链表的头指针
    USHORT          nUnitSize;        //内存块中每个内存单元的字节大小
    USHORT          nInitSize;        //第一个内存块内存单元的个数
    USHORT          nGrowSize;        //后面要增加的内存块的内存单元的个数
 
public:
                     MemoryPool( USHORT nUnitSize,
                                  USHORT nInitSize = 1024,
                                  USHORT nGrowSize = 256 );  
                    ~MemoryPool();    //都是函数原型声明，在类外具体实现
 
    void*           Alloc();        //实际的给程序分配内存单元的接口函数
    void            Free( void* p );    //实际的程序释放归还内存单元给内存池的接口函数
};
```

MemoryBlock为内存池中附着在真正用来为内存请求分配内存的内存块头部的结构体，它描述了与之联系的内存块的使用信息
```c++
struct MemoryBlock
{
    USHORT          nSize;    //本内存块中内存单元的总字节大小
    USHORT          nFree;    //本内存块中空闲的内存单元个数
    USHORT          nFirst;   //本内存块中下一个可用的空闲内存单元下标位置
    USHORT          nDummyAlign1; //虚设的用于字节对齐的2字节，没实际用处
    MemoryBlock*  pNext;    //内存块链表的下一个指针
    char            aData;    //实际内存单元开始的1字节，给出首地址，
            //后面个内存单元地址都在此字节地址基础上加上偏移量（nFirst*nUnitSize）    
 
    //重载new操作符
    static void* operator new(size_t size, USHORT nTypes, USHORT nUnitSize)
    {
        size = sizeof(MemoryBlock) + nTypes * nUnitSize;
        return ::operator new(size);    //调用原始operator new 只分配空间
    }
    static void  operator delete(void *p)
    {
        ::operator delete (p);    //  释放对应的operator new 的空间
    }
 
    MemoryBlock (USHORT nTypes = 1, USHORT nUnitSize = 0);  //nTypes为内存单元个数
    ~MemoryBlock() {}      //内存块不做析构释放内存，交给内存池统一管理
};
```

# 进程调度
（1）先来先服务调度算法
（2）最短工作优先（SJF）  
（3）最短剩余时间优先（SRTF）  
（4）最高响应比优先（HRRF）  
（5）优先级调度（Priority）  
（6）轮转调度（RR）  
其中，SJF、SRTF为非抢占调度，其余为抢占式调度  

响应比：(等待时间+要求服务时间)/要求服务时间



# 孤儿进程和僵死进程
1.孤儿进程是怎么产生的？  
一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

2.僵死进程是怎么产生的？
一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。

3.危害？  
僵尸进程会占用系统资源，如果很多，则会严重影响服务器的性能  
孤儿进程不会占用系统资源，最终是由init进程托管，有inti进程来释放

4.如何避免僵死进程的产生？

让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid()通知内核释放僵尸进程  

利用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数

让僵尸进程变成孤儿进程，由init回收，就是让父亲死亡


# 分页式内存管理


# 分段式内存管理


# 段页式内存管理


# 什么是虚拟内存
　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块（称为帧，通常页和帧大小相等）还有一些没有加载的内存中的对应在硬盘上。
  
　　请求分页系统、请求分段系统、请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。 
  
   <div align="center"> <img src="./虚拟内存.jpg" width="600"/> </div><br>
   
　　由上图可以看出，虚拟内存实际上可以比物理内存大，当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如0，1，2）如果虚拟内存的页并不存在于物理内存中（如 3，4）会产生缺页中断，从磁盘中取得缺得的页存入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

# 页面置换算法

1.FIFO先进先出算法：在操作系统中经常被用到，比如作业调度  
2.LRU（least recently use）最近最少使用算法：根据使用时间到现在的长短来判断  
3.LFU(least frequently use)最少使用次数算法：根据使用次数来判断  
4.OPT(Optimal replacement)最优置换算法：理论最优，就是要保证置换出去的是不再被使用的页，或者是实际内存中最晚使用的算法


# 颠簸
颠簸本质是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的也都在使用，它置换一个页，但立刻再次需要这个页。因此，会不断出现缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）  
内存颠簸的解决策略包括：  
1.如果是因为页面替换策略失误，可以修改替换算法来解决这个问题。  
2.如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。  
3.否则，还剩下两个办法，终止该进程和增加物理内存容量

# 虚拟内存的作用
小内存运行大作业

# 虚拟内存的实现


# Linux如何避免内存碎片化
1.伙伴算法，用于管理物理内存，避免内存碎片
2.高速缓存Slab层用于管理内核分配内存，避免碎片。


# 内部碎片和外部碎片
在内存管理中，内部碎片是已经被分配出去的内存空间大于请求所需的内存空间。  
外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲快。  
固定分区存在内存碎片，可变式分区分配会存在外部碎片  
页式虚拟存储系统存在内部碎片，段式虚拟存储系统存在外部碎片。  
为了有效的利用内存，使内存产生更少的 碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片  
为了共享要分段，在段的换入换出时形成外部碎片，比如5k的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片。


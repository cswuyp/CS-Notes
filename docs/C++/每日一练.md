#每日一练
* [1. 字典序](#1-字典序)
* [2. 卖买股票的最大收益](#2-卖买股票的最大收益)
* [3. 卖买股票的最佳时机](#3-买卖股票的最佳时机)
* [4. 找出单独出现的数字](#4-找出单独出现的数字)
* [幸运数字](#5-幸运数字)


# 1. 字典序
给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。
对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2. 
对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…
输入描述:
输入仅包含两个整数n和m。

数据范围: 

对于20%的数据, 1 <= m <= n <= 5 ; 

对于80%的数据, 1 <= m <= n <= 10^7 ; 

对于100%的数据, 1 <= m <= n <= 10^18.
输出描述:
输出仅包括一行, 即所求排列中的第m个数字.
示例1
输入
11 4
输出
2


```C++
//算法思想：将字典序视作一个树，寻找m次则循环m次来找寻结果
//如果在这个区间内则M在这个区间内查找，否则让梯度乘以10向上查找，直到找寻一个区间内，让i每次加1一个一个查找
//第一步while循环是判断是否查到这个位置，第二次则是写出num在这个区间内有多少个数
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    long n,m;
    cin>>n>>m;
    long i=1;
    m--;//如果要查找第一个数字那么就是1
    while(m!=0)
    {
        long low=i,high=i+1;
        long num=0;
        while(low<=n)//这里是可以取等号的
        {
            num+=min(n+1,high)-low;
            low*=10;
            high*=10;
        }
        if(num>m)//如果m>num即数字不在这个区间内，i每次*10向上寻找
        {
            i*=10;
            m--;//例如：10和100是i*10后的不同结果，但是两者其实是相邻的，也就是只需要做m--就可以了
        }
        else//如果在这里区间内则每次i自增1来寻找
        {
            m-=num;
            i++;
        }
    }
    cout<<i<<endl;
    return 0;
}
```

# 2. 卖买股票的最大收益

1.1 问题描述
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

1.2 输入与输出
1.3 样例

1.3.1 样例1
输入: [7,1,5,3,6,4]

输出: 7

解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

1.3.2 样例2
输入: [1,2,3,4,5]

输出: 4

解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

1.3.3 样例3
输入: [7,6,4,3,1]

输出: 0

解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

2 思路描述与代码
2.1 思路描述（贪心法）
把所有可能获利的交易都吃掉，局部最优可以获得全局最优。
算差分数组，把差分数组中所有为正的元素都加起来就是最大收益。

比如输入: [7,1,5,3,6,4]

差分数组为:[0,-6,4,-2,3,-2]

最大收益为 4 + 3 = 7

 
代码：

 原理：因为我们求的只是最大的收益，而不需要我们记录什么时候买什么时候卖，此时我们需要做的是比较相邻两天的股票价格，如果是涨就继续持有（如果还未购入就购入），如果是跌就在跌的前一天抛出（如果还未购入就不要购入），此时用到的就是差分数组，把正数相加。
 
```C++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
        vector<int> price;
        int temp;
        int sum=0;
        while(cin>>temp)
        {
                price.push_back(temp);
        }
        for(int i=0;i<price.size();i++)
        {
                if(price[i+1]>price[i])
                {
                        sum+=price[i+1]-price[i];
                }
        }
        cout<<sum<<endl;
        return 0;
}
```

分析：时间复杂度：O（n），空间复杂度O(1) 

拓展：此题还可以变为卖买股票的最佳时机，这时就需要我们申请一个数组来存放卖买股票的时间


# 3. 卖买股票的最佳时机

1.1 问题描述
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润，并输出获得最大利润时需要对股票做的卖买操作。你可以尽可能地完成更多的交易（多次买卖一支股票）。

在卖买股票的最佳收益的基础上增加卖买股票的时机，即需要计算在哪一天买入股票和在哪一天卖出股票，如果当天要卖出股票则输出-1，如果当天要买入股票则输出1，如果当天不做任何操作则输出0.

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

1.3.1 样例1
输入: [7,1,5,3,6,4]

输出: 0 1 -1 1 -1 0 

解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

```C++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    int temp;
    int flag = 0;//记录卖买情况
    vector<int>price;
    vector<int>vec;
    while (cin >> temp)
    {
        price.push_back(temp);
    }
    price.push_back(0);//主动的往价格表最后一天之后加入一个价格为0的股票价格，这样才能对股票价格做一个for循环判断就可以而不需要再对
    //最后一天的股票进行一次单独的判断，0是最低价格则可以使得递增的股票价格也能在最后一天做卖出操作，如果不是递增则最后一天也能进行判断
    for (int i = 0; i < price.size()-1; i++)
    {
        if (flag == 0)//还未买入
        {
            if (price[i + 1] > price[i])
            {
                flag = 1;
                vec.push_back(1);
            }
            else
            {
                vec.push_back(0);
            }
        }
        else//已经买入
        {
            if (price[i + 1] > price[i])
            {
                vec.push_back(0);
            }
            else
            {
                vec.push_back(-1);
                flag = 0;
            }
        }
    }
    for (auto it : vec)
    {
        cout << it << " ";
    }
    cout << endl;
    return 0;
}
```
# 4. 找出单独出现的数字
描述  
给出N个数字。其中仅有一个数字出现过一次，其他数字均出现过两次，找出这个出现且只出现过一次的数字。要求时间和空间复杂度最小。

输入  
输入多个数字，每个数字以空格分开。数字数量 N < 20，输入数字的最大值小于 256.

输出  
输出内容为只出现过唯一一次的数字

输入样例  
10 10 11 12 12 11 16  
输出样例  
16

解题思路：因为我们事先已经知道了只有一个数出现一次其他的所有的数字都是出现两次，出现两次我们就可以采用^异或运算符来消除（异或两个相同的数会得到0，和全0异或，结果不变；和全1异或，结果会得到自己的取反。）  
有公式：a^b^a^b=(a^a)^(b^b)，所以我们可以知道10^10^11^12^12^11^16=16

时间复杂度为O(n),空间复杂度为O(1)

代码如下：
```
#include <iostream>
using namespace std;
int main()
{
	int temp;
	int result = 0;
	while (cin >> temp)
	{
		result ^= temp;
	}
	cout << result << endl;
	return 0;
}
```
此外，如果题目变为只有一个数字出现奇数次，其他的都出现偶数次也可以这样写，”因为两两抵消”。

另外，还有一些时间复杂度和空间复杂度比较高的解法有如：两个循环遍历（O(n^2)），用map容器等，也可以是先排序后再进行操作，但是时间复杂度和时间复杂度都比用位操作符答。

# 5. 幸运数字
题目描述  
小雅同学认为6,8是她的幸运数字,而其他数字均不是,一个幸运数是指在十进制表示下只含有幸运数字的数。给定你一个区间（a,b）a和b之间（其中包括a和b幸）运数的个数。

输入描述:  
输入两个整数a和b，a的取值范围在1和1000000000之间（其中包括1和1000000000），b的取值范围在a和1000000000之间（其中包括a和1000000000）。  
输出描述:  
返回a和b之间的幸运数个数，如果入参不合法，请输出-1  
示例1  
输入  
1 10  
输出  
2  
说明  
6,8,6666,88888,6668888,68686688均为幸运数字，当a=1，b=10函数返回值为2。  
代码：  
```
#include <iostream>
using namespace std;
const int maxn = 1e5 + 5;
#define MAX 1000000000
int lucky[maxn];
int top;
void init();
//查询[a,b]范围之间的幸运数可以转化为查找[0,a]和[0,b]范围之间的幸运数，然后
//两者的差分就是[a,b]之间的幸运数
int main()
{
	init();
	int count_a = 0, count_b = 0, count = 0;//统计幸运数个数
	int a, b;
	cin >> a >> b;
	for (int i = 0; i < maxn; i++)
	{
		if (a > lucky[i])
		{
			count_a++;
		}
		if (b > lucky[i])
		{
			count_b++;
		}
		if (a < lucky[i] && b < lucky[i])
		{
			break;
		}
	}
	count = count_b - count_a;
	cout<<count << endl;
}

//初始化数组，把所有可能的值都存到数组中，相当于画一棵二叉树
void init()
{
	int i = 0;
	top = 2;
	lucky[0] = 6;
	lucky[1] = 8;
	while (1) 
	{
		if (i > 512)
			break;
		lucky[top++] = lucky[i] * 10 + 6;
		lucky[top++] = lucky[i] * 10 + 8;
		i++;
	}
}
```

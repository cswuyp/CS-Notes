* [1.面向对象的三个基本特征](#1-面向对象的三个基本特征)
* [2.虚函数的实现原理](#2-虚函数的实现原理)
* [3.怎么用C语言实现虚函数的功能](#3-怎么用c语言实现虚函数的功能)
* [4.在C++中的虚函数表是什么时期建立的](#4-在c中的虚函数表是什么时期建立的)
* [5.在C++对象内存布局](#5-在c对象内存布局)
* [6.在C++自定义的函数一定要先声明或者定义在main函数前面吗？](#6-在c自定义的函数一定要先声明或者定义在main函数前面吗？)
* [7.sort函数的实现原理](#7-sort函数的实现原理)
* [8.malloc函数的实现原理](#8-malloc函数的实现原理)
* [9.进程池和线程池](#9-进程池和线程池)
* [10.构造函数可否为虚函数](#10-构造函数可否为虚函数)
* [11.父类的析构函数为什么要声明为虚函数](#11-父类的析构函数为什么要声明为虚函数)
* [12.进程相关知识](#12-进程相关知识)
* [13.线程相关知识](#13-线程相关知识)
* [14.线程和进程之间的区别](#14-线程和进程之间的区别)

* [STL容器的使用](#STL容器的使用)
  * [vector](#vector)
    * [vector基础](#vector基础)
  * [map](#map)
    * [map基础](#map基础)
  * [set](#set)
    * [set基础](#set基础)







# 1. 面向对象的三个基本特征
1.封装  
简单来讲：将现实世界的事物抽象成计算机领域中的对象，对象同时具有属性和行为，这种抽象就是封装。  
封装的一个重要特性：数据隐藏，对象只对外提供与其它对象交互的必要接口，而将自身的某些属性和实现细节对外隐藏，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或者错误的使用了对象的私有部分，这样就在确保正常交互的前提下，保证了安全性。  
2.继承  
面向对象的一个重要特性是复用性，继承是实现复用性的一个重要手段，可以在不重复编写以实现的功能的前提下，对功能进行复用和拓展。  
继承概念的实现方式有两类：实现继承与接口继承  
实现继承是指直接使用基类的属性和方法而无需额外编码的能力。  
接口继承是指仅使用属性和方法的名称，但是子类必须提供实现的能力。  
3.多态  
当存在继承关系时，允许将父类对象看成和它的一个或多个子类对象等同，这样可以根据当前赋给父类对象的子类对象的具体特性以不同的方式进行运行，  
多态的几个前提  
a.要有继承关系  
b.要有方法重写  
c.要有父类引用指向子类对象  
多态的好处  
a.提高了代码的维护性（继承保证）  
b.提高了代码的扩展性（由多态保证）  
多态的限制  
不能使用子类的特有属性和行为  

# 2. 虚函数的实现原理

我们可以从虚函数表和虚函数指针来了解虚函数的实现原理。  
简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。
含有虚函数的类会
http://www.cnblogs.com/malecrab/p/5572730.html

# 3. 怎么用C语言实现虚函数的功能
参照前面C++虚函数的实现原理，可以自己添加虚函数指针和虚函数表来实现虚函数功能。  

# 4. 在C++中的虚函数表是什么时期建立的
虚函数表是编译期确定的，虚函数表中存放的是虚函数的地址，而虚函数的地址是在编译期间就确定的所以虚函数表应该也是在编译期就确定的。 
我们在《深度探索C++对象模型》的4.2节能够找到完美的答案，具体摘抄如下：  
“表格中的virtual functions地址是如何构建起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或者替换之。由于程序执行时，表格的大小和内容都不会改变，所以其构建和存取皆可以由编译器完美掌控，不需要执行期的任何介入。”

# 5. 在C++对象内存布局
https://www.cnblogs.com/wuyepeng/p/9863296.html

# 6. 在C++自定义的函数一定要先声明或者定义在main函数前面吗？
不一定，C++中的执行总是从main函数开始的（无论main放在什么位置），如果自定义的函数放于main函数之后则需要在main函数前声明该自定义函数，如果自定义的函数放于main函数前则不需要额外的声明，否则在main函数中调用该自定义函数时会出现无法识别。


# 7. sort函数的实现原理

# 9.进程池和线程池
动态创建子进程（或子线程）来实现并发服务器的缺点如下：  
1.动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户反应。  
2.动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理），这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量的CPU时间。  
3.动态创建的子进程是当前进程的的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。  

进程池的实现原理：  
　　进程池是由服务器预先创建的一组子进程，（线程池中的线程数量应该和CPU数量差不多）。进程池中的所有子进程都运行这相同的代码，并且有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即他们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。  
　　当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态的创建子进程，选择一个已存在的子进程的代价显然要小得多。至于主进程选择哪一个子进程来为新任务服务，则有两种方式：  
1.主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力。  
2.主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠的工作队列上。  
　　当选择好子进程后，主进程还需要使用某种通知进制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使用）。在父线程和子线程之间传递数据要简单得多，因为我们可以把这些数据定义为全局的，那么他们本身就是被所有线程共享的。  
  
进程编程实例1：  
```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include<stdio.h>
int main()
{
        pid_t child_pid;

        /* 创建一个子进程 */
        child_pid = fork();
        if(child_pid == 0)
        {
                printf("child pid\n");
                exit(0);
        }
        else
        {
                printf("father pid\n");
                sleep(60);
        }

        return 0;
}
```

# 14. 线程和进程之间的区别
进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统的基本单位。  
线程：是进程的一个执行单元，是进程内调度实体，比进程更小的独立运行的基本单位。线程也称为轻量级进程。  
一个程序至少一个进程，一个进程至少一个线程。  
根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

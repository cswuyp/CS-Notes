* [数据结构与算法](#数据结构与算法)
  * [排序](#排序)
     * [各排序时间复杂度](#各排序时间复杂度)
     * [非线性时间比较类排序](#非线性时间比较类排序)
      * [交换排序](#交换排序)
        * [冒泡排序](#冒泡排序)
        * [快速排序](#快速排序)
      * [插入排序](#插入排序)
        * [简单插入排序](#简单插入排序)
        * [希尔排序](#希尔排序)
      * [选择排序](#选择排序)
        * [简单选择排序](#简单选择排序)
        * [堆排序](#堆排序)
      * [归并排序](#归并排序)
        * [二路归并排序](#二路归并排序)
        * [多路归并排序](#多路归并排序)
    * [线性时间比较类排序](#非线性时间比较类排序)
       * [计数排序](#计数排序)
        * [基数排序](#基数排序)
         * [桶排序](#桶排序)
* [十大经典排序算法动画版](https://www.cnblogs.com/onepixel/articles/7674659.html)
* [排序算法的稳定性及其意义](#排序算法的稳定性及其意义)
  
* [树和二叉树](#树和二叉树)
  * [树的定义和基本术语](#树的定义和基本术语)
  * [树的定义](#树的定义)
  * [树的基本术语](#树的基本术语)
* [二叉树](#二叉树)
  * [二叉树的定义](#二叉树的定义)
  * [二叉树的性质](#二叉树的性质)
  * [二叉树的存储结构](#二叉树的存储结构)
* [遍历二叉树和线索二叉树](#遍历二叉树和线索二叉树)
  * [遍历二叉树](#遍历二叉树)
  * [线索二叉树](#线索二叉树)
* [树和森林](#树和森林)
  * [树的存储结构](#树的存储结构)
  * [森林与二叉树的转换](#森林与二叉树的转换)
  * [树和森林的遍历](#树和森林的遍历)
* [赫夫曼树及其应用](#赫夫曼树及其应用)
  * [赫夫曼树d的基本概念](#赫夫曼树的基本概念)
  * [赫夫曼树的构造算法](#赫夫曼树的构造算法)
  * [赫夫曼编码](#赫夫曼编码)
  
* [图的定义和基本术语](#图的定义和基本术语)
  * [图的定义](#图的定义)
  * [图的基本术语](#图的基本术语)
* [图的存储结构](#图的存储结构)
  * [邻接矩阵](#邻接矩阵)
  * [邻接表](#邻接表)
* [图的遍历](#图的遍历)
  * [深度优先遍历](#深度优先遍历)
  * [广度优先遍历](#广度优先遍历)
* [图的应用](#图的应用)
  * [最小生成树](#最小生成树)
  * [最短路径](#最短路径)
  * [拓扑排序](#拓扑排序)
  * [关键路径](#关键路径)
  
* [查找的基本概念](#查找的基本概念)
* [线性表的查找](#线性表的查找)
  * [顺序查找](#顺序查找)
  * [折半查找](#折半查找)
* [树表的查找](#树表的查找)
  * [二叉查找](#二叉查找)
  * [平衡二叉树](#平衡二叉树)
  * [B-树](#B-树)
  * [B+树](#B+树)
* [散列表的查找](#散列表的查找)
  * [散列表的基本概念](#散列表的基本概念)
  * [散列函数的构造方法](#散列函数的构造方法)
  * [处理冲突的方法](#处理冲突的方法)
  * [散列表的查找](#散列表的查找)
 
 
* [算法思想](#算法思想)
  
  # 数据结构与算法
  ## 排序
  ### 各排序时间复杂度
  排序方法|时间复杂度（平均）|时间复杂度（最坏）|时间复杂度（最好）|空间复杂度|稳定性
  ---|:--:|:--:|:--:|:--:|---:
  插入排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定
  希尔排序|O(n<sup>1.3</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|不稳定
  选择排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|不稳定
  堆排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(1)|不稳定
  冒泡排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定
  快速排序|O(nlog<sub>2</sub>n)|O(n<sup>2</sup>)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|不稳定
  归并排序|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(n)|稳定
  计数排序|O(n+k)|O(n+k)|O(n+k)|O(n+k)|稳定
  桶排序|O(n+k)|O(n<sup>2</sup>)|O(n)|O(n+k)|稳定
  基数排序|O(n*k)|O(n*k)|O(n*k)|O(n+k)|稳定


# #非线性时间比较类排序
## 交换排序
### 冒泡排序
算法描述：<br>
1.比较相邻的元素。如果第一个比第二个大，就交换它们两个。  
2.对每一对相邻元素作相同的工作，从开始第一对到结尾最后一对，这样在最后的元素应该会是最大的数。  
3.针对所有的元素重复以上的步骤，除最后一个。  
4.重复步骤1~3，直到排序完成。  
代码实现:<br>
```
void BubbleSort(DataType a[],int n)
{
	int i,j,flag=1;
	DataType temp;
	for(i=1;i<n&&flag==1;i++)
	{
		flag=0;
		for(j=0;j<n-i;j++)//注意这里的取值范围                    
		{
			if(a[j].key>a[j+1].key)  
			{
				flag=1;
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
			}
		}
	}
}
```
### 快速排序
快速排序的算法思想：  
通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。  
算法描述：  
快速排序使用分治法来把一串分为两个子串。  
1.从数列中挑出一个元素，称为“基准”。  
2.重新排序数列，所有元素比基准小的摆放在基准前面，所有元素比基准大的摆放在基准后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作。  
3.递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。  
代码实现：
```c++
#include<iostream>
#include<vector>
using namespace std;
int quicksort(int *a, int low, int high)
{
    int key = a[low];
    while (low < high)
    {
        while (low<high&&a[high]>=key)//记得是要先从后往前
        {
            high--;
        }
        a[low] = a[high];
        while (low < high&&a[low] <= key)//这里要取等号不然会陷入死循环
        {
            low++;
        }
        a[high] = a[low];
    }
    a[low] = key;
    return low;
}
void QSort(int *a, int low, int high)
{
    if (low < high)
    {
        int mid = quicksort(a, low, high);
        QSort(a, low, mid - 1);
        QSort(a, mid + 1, high);
    }
 
}
int main()
{
    int a [11] = { 2,6,4,5,54,53,53,5,34,34,32};
    QSort(a, 0, 10);
    for (int i = 0; i < 11; i++)
    {
        cout << a[i] << " ";
    }
    return 0;
}
```
## 插入排序
### 简单插入排序
原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
算法描述：  
1.从第一个元素开始，该元素可以认为已经被排序  
2.取下一个元素，在已经排好序的元素序列中从后向前扫描  
3.如果该元素（已排好序）大于新元素，将该元素后移一位  
4.重复3，直到找到已排序的元素小于或者等于新元素的位置  
5.将新元素插入到该位置后  
6.重复步骤2~5
代码：  
```c++
void InsertSort(int array[],int n)
{
	for (int i = 1; i < n; i++)
	{
		if (array[i] < array[i - 1])//后面元素的值小于前面的
		{
			int key = array[i];//借助一个变量存放待排序的元素的值
			array[i] = array[i - 1];
			int j;
			for (j = i - 1; key < array[j]; j--)//把待排序的值跟已排好序的序列做比较
			{
				array[j + 1] = array[j];
			}
			array[j + 1] = key;//放到正确位置
		}
	}
}
```
### 希尔排序
1959年Shell发明，第一个突破O(n<sup>2</sup>)的排序算法，是简单插入排序的改进版，它与插入排序的不同之处在于，它会优先比较距离教远的元素。希尔排序又叫缩小增量排序。  
算法描述：    
先将整个待排序的记录序列分割称为若干个子序列分别进行直接插入排序，具体算法描述:    
1.选择一个增量序列t1，t2，t3，......tk，其中ti>tj（i<j）,tk=1;  
2.按增量序列个数，对序列进行k趟排序。  
3.每趟排序，根据对应的增量ti，将待排序序列分割成若干长度为m的子序列，分别对应各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。  
代码：  
```

```

# 选择排序
## 简单选择排序
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，知道所有的元素均排序完毕。  
算法描述：  
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：    
1.初始状态：无序区为[1...n]，有序区为空。  
2.第i趟排序(i=1,2,3...n-1),开始时，当前有序区和无序区分别为R[1...i-1]和R(i...n)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1...i]和R[i+1...n]分别变为记录个数增加1个的新有序区和记录个数减少1的新无序区。  
3.n-1趟结束，数组有序了。  
代码：  
```c++
void SelectSort(int array[], int n)
{
	for (int i = 0; i < n; i++)//要做趟遍历
	{
		int key = i;
		for (int j = i + 1; j < n; j++)//从剩余的未排序的元素中找出最小的
		{
			if (array[j] < array[key])
			{
				key = j;
			}
		}
		if (key != i)
		{
			int temp = array[i];
			array[i]=array[key];
			array[key] = temp;
		}
	}
}
```
算法分析：  
1.因为最后需要进行交换操作把最小（大）的元素放到正确的位置，该交换操作肯能会改变相同大小的元素的前后顺序发生改变，所以选择排序是不稳定的排序。  
2.移动记录次数较少。  
3.需要借助一个辅助空间，所以空间复杂度为O（1）。  
4.最好情况是正序不需要移动，最坏情况是逆序。  
## 堆排序
堆排序是指利用堆这种数据结构所设计的一种排序算法，堆是一个完全二叉树结构，子节点的键值总是小于（或者大于）它的父节点。    
算法描述：  
1.将初始待排序关键字序列（R1，R2...Rn）构建成大根堆，此堆为初始的无序区。  
2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区（R1，R2，...Rn-1）和新的有序区（Rn）且满足R[1,2...n-1]<=R[n]。    
3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区（R1，R2,...Rn-1）调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区（R1,R2,...Rn-2）和新的有序区（Rn-1，Rn）。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。  
代码：  
```c++
void HeapAdjust(int array[], int s, int m)
{
	//建立以r[s]为根的小根堆
	int key = array[s];
	for (int i = 2 * s+1; i < m; i *= 2)//注意因为数组是从下标0开始，所以这里的i值需要 +1
	{
		//当前i指向节点左孩子
		if (i+1 < m&&array[i] > array[i + 1])//判断节点右孩子是否比左孩子小，如果小则把下标i指向节点右孩子
		{
			i++;
		}
		//通过上面的步骤取出节点左右孩子中较小的一个再跟节点的值做比较，如果孩子的值大于节点的值则不做任何处理
		//否则把结点孩子较小的值替换结点的值
		if (key < array[i])
		{
			break;
		}
		else
		{
			array[s] = array[i];
			s = i;//更新节点的新位置
		}
	}
	array[s] = key;//把key值插入到正确位置
}


void HeapSort(int array[], int n)
{
	//调整为小根堆
	for (int i = n / 2 - 1; i >= 0; i--)//注意因为数组下标从0开始，所以这里需要 -1
	{
 		HeapAdjust(array, i, n);
	}
	//取出最小值放于未排序序列的最后，然后调整堆
	for (int i = n-1; i >= 0; i--)
	{
		int temp = array[0];
		array[0] = array[i];
		array[i] = temp;
		HeapAdjust(array, 0, i);//每取出一个元素需要重新调整一次堆
	}
	return;
}

int main()
{
	//int array[10] = { 10,9,81,7,6,5,4,3,2,1 };
	int array[10] = { 1,2,3,4,51,6,7,8,9,10 };
	HeapSort(array,10);
	for (auto i : array)
	{
		cout << i << " ";
	}
	cout << endl;
	return 0;
}
```
算法分析：  
1.需要一个记录大小供交换用的辅助存储空间，所以空间复杂度为O(1)。  
2.只能用于顺序存储结构，不能用于链式存储结构。  
3.不稳定排序。  
4.初建堆所需要的比较次数较多，因此记录数较少时不宜采用。当记录较多时较为高效。
# 归并排序
## 二路归并排序
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序。若将每个有序表合并成一个有序表，称为2-路归并。  
算法描述：  
1.把长度为n的输入序列分成两个长度为n/2的子序列。  
2.对这两个子序列分别采用归并排序。  
3.将两个排序好的子序列合并成一个最终排序序列。  
代码：  
```c++
void Merge(int array[], int temp[], int low, int mid,int high)
{
	int s1 = low;//左侧序列
	int s2 = mid + 1;//右侧序列
	int k = low;
	while (s1 <= mid && s2 <= high)//如果左右序列都不为空
	{
		if (array[s1] <= array[s2])//如果左侧序列第一个元素小于右侧序列第一个元素
		{
			temp[k++] = array[s1++];
		}
		if (array[s1] >= array[s2])
		{
			temp[k++] = array[s2++];
		}
	}
	while (s1 <= mid)//如果只剩左侧序列
	{
		temp[k++] = array[s1++];
	}
	while (s2 <= high)//如果只剩右侧序列
	{
		temp[k++] = array[s2++];
	}
}

void MergeSort(int array[], int temp[], int low, int high)
{
	if (low < high)
	{
		int mid = (low + high) / 2;
		MergeSort(array, temp, low, mid);
		MergeSort(array, temp, mid + 1, high);
		Merge(array, temp, low, mid, high);
	}
}
int main()
{
	int array[10] = { 10,9,81,7,6,5,4,3,2,1 };
	//int array[10] = { 1,2,3,4,51,6,7,8,9,10 };
	int temp[10];//需要一个新区存放已经排好序的元素
	MergeSort(array, temp, 0, 9);
	for (auto i : temp)
	{
		cout << i << " ";
	}
	cout << endl;
	return 0;
}
```
算法分析：  
归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。
## 多路归并排序

# 线性时间非比较类排序
## 基数排序
基数排序是按照低位先排序，然后收集，再按照高位排序，然后再收集，依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。  
算法描述：  
假设原来有一串数值如下所示：
73, 22, 93, 43, 55, 14, 28, 65, 39, 81
首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：
0
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39


第二步：
接下来将这些桶子中的数值重新串接起来，成为以下的数列：
81, 22, 73, 93, 43, 14, 55, 65, 28, 39
接着再进行一次分配，这次是根据十位数来分配：
0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93


第三步：
接下来将这些桶子中的数值重新串接起来，成为以下的数列：
14, 22, 28, 39, 43, 55, 65, 73, 81, 93
这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。

代码：  
```c++
/**
* name:基数排序
* time:15/8/16 15:00
* environment: ubuntu 14.04， sublime text 3
*/
#include <iostream>
using namespace std;
 
/*
* 打印数组
*/
void printArray(int array[],int length)
{
	for (int i = 0; i < length; ++i)
	{
		cout << array[i] << " ";
	}
	cout << endl;
}
/*
*求数据的最大位数,决定排序次数
*/
int maxbit(int data[], int n) 
{
    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int tmp[n];
    int count[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
}
 
int main()
{
	int array[10] = {73,22,93,43,55,14,28,65,39,81};
	radixsort(array,10);
	printArray(array,10);
	return 0;
}
 
//结果
//14 22 28 39 43 55 65 73 81 93  
```
## 桶排序
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键在于这个映射函数的确定。桶排序的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。  
算法描述：  
1.设置一个定量的数组当作空桶。  
2.遍历输入数组，并且把数据一个一个放到对应的桶里去。  
3.对每个不是空的桶进行排序。  
4.从不是空的桶里把排好序的数据拼接起来。  
代码：  
```

```
算法描述：  
桶排序最好情况下使用线性时间O(n),桶排序的时间复杂度，取决于对各个桶之间数据进行排序的时间复杂度，因为其他部分的时间度都为O(n),很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相同的空间消耗就会增大。  
## 计数排序
计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。  
算法描述：  
1.找出待排序的数组中最大和最小的元素。  
2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项。  
3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）。  
4.反向填充目标数组：将每个元素i放在新数组的第C（i）项，每放一个元素就将C（i）减去1。  
代码：  
```

```
算法分析：  
计数排序是一个稳定的排序算法。当输入的元素是n个0到k之间的整数时，时间复杂度是O(n+k)，空间复杂度是O(n+k)，其排序速度快于任何比较排序算法，当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。  

# 排序算法的稳定性及其意义
稳定性的定义：<br>
    假定在待排序的记录中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r1=r2，且r1在r2前面，排序后的序列中，r1仍然在r2前面，则称这种排序算法是稳定的；否则称为不稳定的。
    
判断方法：<br>
    对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性，而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种特定的条件下也可以变为不稳定的算法。
    
例如：对于如下的冒泡排序算法，如果将记录交换的条件改为a[j].key>=a[j+1].key，则两个相等的记录就会交换位置。
```
void BubbleSort(DataType a[],int n)
{
	int i,j,flag=1;
	DataType temp;
	for(i=1;i<n&&flag==1;i++)
	{
		flag=0;
		for(j=0;j<n-i;j++)                    
		{
			if(a[j].key>a[j+1].key)  //如果改为a[j].key>=a[j+1].key,就不稳定了
			{
				flag=1;
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
			}
		}
	}
}
```
常见算法的稳定性：  
堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

稳定的意义：  
1.如果只是简单的进行数字的排序，那么稳定性将毫无意义。  

2.如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧毫无意义  

3.如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧毫无意义。  

4.除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序（当然如果需要不需要保持初始的排序意义，那么使用稳定性算法依旧毫无意义）。  



# 树和二叉树

# 树的定义和基本术语
# 树的定义
# 树的基本术语
# 二叉树
# 二叉树的定义
# 二叉树的性质
# 二叉树的存储结构

# 遍历二叉树和线索二叉树
# 遍历二叉树
前序遍历二叉树
```c++
void InOrderTraverse(BiTree T)
{
	if (T)
	{
		cout << T->data;
		InOrderTraverse(T->lchild);
		InOrderTraverse(T->rchild);
	}
}
```
中序遍历二叉树
```c++
void InOrderTraverse(BiTree T)
{
	if (T)
	{
		InOrderTraverse(T->lchild);
		cout << T->data;
		InOrderTraverse(T->rchild);
	}
}
```
后序遍历二叉树
```c++
void InOrderTraverse(BiTree T)
{
	if (T)
	{
		InOrderTraverse(T->lchild);
		InOrderTraverse(T->rchild);
		cout << T->data;
	}
}
```
先序遍历建立二叉树
```c++
void CreateBiTree(BiTree &T)
{
	cin >> ch;
	if (ch == '#')
	{
		T = NULL;
	}
	else
	{
		T = new BiTree;
		T->data = ch;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
	}
}
```
中序遍历二叉树非递归
```c++
void InOrderTraverse(BiTree T)
{
	stack<char>s;
	BiTree p = T;
	BiTree q = new BiTree;
	while (p||!s.empty())
	{
		if (p)
		{
			s.push(p);
			p = p->lchild;
		}
		else
		{
			q = s.top();
			cout << q->data;
			s.pop();
			p = q->rchild;
		}
		
	}
}
```
复制二叉树
```c++
void Copy(BiTree T, BiTree &NewT)
{
	if (T == NULL)
	{
		NewT = NULL;
		return;
	}
	else
	{
		NewT = new BiTree;
		NewT->data = T->data;
		Copy(T->lchild, NewT->lchild);
		Copy(T->rchild, NewT->rchild);
	}
}
```
计算二叉树的深度
```c++
int Depth(BiTree T)
{
	if (T == NULL)
	{
		return 0;
	}
	else
	{
		m = Depth(T->lchild);
		n = Depth(T->rchild);
		if (m > n)
		{
			return (m + 1);
		}
		else
		{
			return (n + 1);
		}
	}
}
```
# 线索二叉树
# 树和森林
# 树的存储结构
# 森林与二叉树的转换
# 树和森林的遍历
# 赫夫曼树及其应用
# 赫夫曼树的基本概念
# 赫夫曼树的构造算法
# 赫夫曼编码

# 算法思想
八大算法思想分别是：枚举、递推、递归、分治、贪心、试探法、动态迭代和模拟算法思想。
https://www.cnblogs.com/cailingsunny/p/4590274.html
必须知道的10种基础算法  https://blog.csdn.net/dataiyangu/article/details/79774145
